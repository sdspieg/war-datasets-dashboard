import {
  C,
  Fr,
  In,
  It,
  Jt,
  Kt,
  Nt,
  O,
  Ot,
  St,
  Ur,
  We,
  Wn,
  Xe,
  animated,
  bt,
  g,
  gn,
  k,
  pr,
  to,
  useSpring,
  useSprings,
  vn,
  wt,
  zt
} from "./chunk-3YO72H2Y.js";
import {
  arc_default,
  lineRadial_default,
  linear,
  linearClosed_default
} from "./chunk-F2U6MNST.js";
import {
  require_jsx_runtime
} from "./chunk-RLMGAKMB.js";
import "./chunk-SVG7M4VJ.js";
import {
  __toESM,
  require_react
} from "./chunk-2YIMICFJ.js";

// node_modules/@nivo/radar/dist/nivo-radar.es.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function z() {
  return z = Object.assign ? Object.assign.bind() : function(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = arguments[r2];
      for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
    }
    return e2;
  }, z.apply(this, arguments);
}
function j(e2, r2) {
  if (null == e2) return {};
  var t2, n2, o2 = {}, i2 = Object.keys(e2);
  for (n2 = 0; n2 < i2.length; n2++) t2 = i2[n2], r2.indexOf(t2) >= 0 || (o2[t2] = e2[t2]);
  return o2;
}
var T = function(r2) {
  var t2, n2 = r2.data, o2 = r2.item, i2 = r2.colorByKey, u = r2.fillByKey, c = r2.radiusScale, s = r2.rotation, f = r2.angleStep, m = r2.curveFactory, g2 = r2.borderWidth, v = r2.borderColor, y = r2.fillOpacity, h = r2.blendMode, p = zt(), b = Xe(v, p), x = (0, import_react.useMemo)((function() {
    return lineRadial_default().radius((function(e2) {
      return c(e2);
    })).angle((function(e2, r3) {
      return s + r3 * f;
    })).curve(m);
  }), [c, s, f, m]), B = Ur(), k2 = B.animate, O2 = B.config, I = Fr(x(n2.map((function(e2) {
    return e2[o2];
  })))), M = useSpring({ fill: i2[o2], stroke: b({ key: o2, color: i2[o2] }), config: O2, immediate: !k2 }), K = null != (t2 = u[o2]) ? t2 : M.fill;
  return (0, import_jsx_runtime.jsx)(animated.path, { d: I, fill: K, fillOpacity: y, stroke: M.stroke, strokeWidth: g2, style: { mixBlendMode: h } }, o2);
};
var E = function(e2) {
  var t2 = e2.radius, n2 = e2.angles, o2 = e2.indices, i2 = e2.label, a = e2.labelOffset, d = Ur(), s = d.animate, f = d.config, m = o2.map((function(e3, r2) {
    var o3, i3, l = Jt(n2[r2], t2 + a), d2 = (o3 = n2[r2], (i3 = Nt(o3) + 90) <= 10 || i3 >= 350 || i3 >= 170 && i3 <= 190 ? "middle" : i3 > 180 ? "end" : "start");
    return z({ id: e3, angle: Nt(n2[r2]), anchor: d2 }, l);
  })), g2 = useSprings(m.length, m.map((function(e3) {
    return { transform: "translate(" + e3.x + ", " + e3.y + ")", config: f, immediate: !s };
  })));
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: g2.map((function(e3, t3) {
    var n3 = m[t3];
    return (0, import_react.createElement)(i2, { key: n3.id, id: n3.id, anchor: n3.anchor, angle: n3.angle, x: n3.x, y: n3.y, animated: e3 });
  })) });
};
var H = ["shape"];
var G = (0, import_react.memo)((function(e2) {
  var r2 = e2.radius, t2 = zt(), n2 = Ur(), o2 = n2.animate, i2 = n2.config, d = useSpring({ radius: r2, config: i2, immediate: !o2 });
  return (0, import_jsx_runtime.jsx)(animated.circle, z({ fill: "none", r: to(d.radius, (function(e3) {
    return Math.max(e3, 0);
  })) }, t2.grid.line));
}));
var R = function(r2) {
  var t2 = r2.radius, n2 = r2.rotation, o2 = r2.angleStep, i2 = r2.dataLength, l = zt(), u = (0, import_react.useMemo)((function() {
    return lineRadial_default().angle((function(e2) {
      return n2 + e2 * o2;
    })).radius(t2).curve(linearClosed_default);
  }), [n2, o2, t2]), c = Array.from({ length: i2 }, (function(e2, r3) {
    return r3;
  })), s = Fr(u(c));
  return (0, import_jsx_runtime.jsx)(animated.path, z({ fill: "none", d: s }, l.grid.line));
};
var q = function(e2) {
  var r2 = e2.shape, t2 = j(e2, H);
  return "circular" === r2 ? (0, import_jsx_runtime.jsx)(G, { radius: t2.radius }) : (0, import_jsx_runtime.jsx)(R, z({}, t2));
};
var J = function(r2) {
  var t2 = r2.indices, n2 = r2.levels, o2 = r2.shape, i2 = r2.radius, l = r2.rotation, d = r2.angleStep, c = r2.label, s = r2.labelOffset, f = zt(), m = (0, import_react.useMemo)((function() {
    return { radii: Array.from({ length: n2 }).map((function(e2, r3) {
      return i2 / n2 * (r3 + 1);
    })).reverse(), angles: Array.from({ length: t2.length }).map((function(e2, r3) {
      return l + r3 * d - Math.PI / 2;
    })) };
  }), [t2, n2, i2, l, d]), g2 = m.radii, v = m.angles;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [v.map((function(e2, r3) {
    var t3 = Jt(e2, i2);
    return (0, import_jsx_runtime.jsx)("line", z({ x1: 0, y1: 0, x2: t3.x, y2: t3.y }, f.grid.line), "axis." + r3);
  })), g2.map((function(e2, r3) {
    return (0, import_jsx_runtime.jsx)(q, { shape: o2, radius: e2, rotation: l, angleStep: d, dataLength: t2.length }, "level." + r3);
  })), (0, import_jsx_runtime.jsx)(E, { radius: i2, angles: v, indices: t2, labelOffset: s, label: c })] });
};
var N = function(t2) {
  var i2 = t2.datum, l = t2.keys, d = t2.index, c = t2.formatValue, s = t2.colorByKey, f = t2.radius, m = t2.startAngle, g2 = t2.endAngle, v = t2.arcGenerator, y = t2.tooltip, h = (0, import_react.useState)(false), p = h[0], b = h[1], x = zt(), B = k(), L = B.showTooltipFromEvent, S = B.hideTooltip, k2 = (0, import_react.useMemo)((function() {
    var e2 = l.map((function(e3) {
      return { color: s[e3], id: e3, value: i2[e3], formattedValue: c(i2[e3], e3) };
    }));
    return e2.sort((function(e3, r2) {
      return e3.value - r2.value;
    })), e2.reverse(), e2;
  }), [i2, l, c, s]), O2 = (0, import_react.useCallback)((function(e2) {
    b(true), L((0, import_react.createElement)(y, { index: d, data: k2 }), e2);
  }), [L, y, d, k2]), C2 = (0, import_react.useCallback)((function() {
    b(false), S();
  }), [S, b]), I = (0, import_react.useMemo)((function() {
    var e2 = Jt(m + 0.5 * (g2 - m) - Math.PI / 2, f);
    return { path: v({ startAngle: m, endAngle: g2 }), tipX: e2.x, tipY: e2.y };
  }), [m, g2, f, v]), M = I.path, W = I.tipX, K = I.tipY;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [p && (0, import_jsx_runtime.jsx)("line", { x1: 0, y1: 0, x2: W, y2: K, style: x.crosshair.line }), (0, import_jsx_runtime.jsx)("path", { d: M, fill: "#F00", fillOpacity: 0, onMouseEnter: O2, onMouseMove: O2, onMouseLeave: C2 })] });
};
var Q = function(e2) {
  var r2 = e2.data, t2 = e2.keys, n2 = e2.getIndex, o2 = e2.formatValue, i2 = e2.colorByKey, a = e2.radius, l = e2.rotation, d = e2.angleStep, u = e2.tooltip, c = arc_default().outerRadius(a).innerRadius(0), s = l - 0.5 * d;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: r2.map((function(e3) {
    var r3 = n2(e3), l2 = s;
    return s += d, (0, import_jsx_runtime.jsx)(N, { datum: e3, keys: t2, index: r3, formatValue: o2, colorByKey: i2, startAngle: l2, endAngle: l2 + d, radius: a, arcGenerator: c, tooltip: u }, r3);
  })) });
};
var U = function(r2) {
  var t2 = r2.data, n2 = r2.keys, o2 = r2.getIndex, i2 = r2.colorByKey, l = r2.radiusScale, d = r2.rotation, c = r2.angleStep, m = r2.symbol, g2 = r2.size, v = void 0 === g2 ? 6 : g2, y = r2.color, h = void 0 === y ? { from: "color" } : y, p = r2.borderWidth, b = void 0 === p ? 0 : p, x = r2.borderColor, B = void 0 === x ? { from: "color" } : x, L = r2.enableLabel, S = void 0 !== L && L, k2 = r2.label, O2 = void 0 === k2 ? "value" : k2, C2 = r2.formatValue, I = r2.labelYOffset, M = zt(), W = We(h, M), V = We(B, M), w2 = Wn(O2), A = (0, import_react.useMemo)((function() {
    return t2.reduce((function(e2, r3, t3) {
      var a = o2(r3);
      return n2.forEach((function(n3) {
        var o3 = r3[n3], s = { index: a, key: n3, value: o3, formattedValue: C2(o3, n3), color: i2[n3] };
        e2.push({ key: n3 + "." + a, label: S ? w2(s) : void 0, style: z({ fill: W(s), stroke: V(s) }, Jt(d + c * t3 - Math.PI / 2, l(r3[n3]))), data: s });
      })), e2;
    }), []);
  }), [t2, n2, o2, i2, S, w2, C2, W, V, d, c, l]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: A.map((function(e2) {
    return (0, import_jsx_runtime.jsx)(vn, { x: e2.style.x, y: e2.style.y, symbol: m, size: v, color: e2.style.fill, borderWidth: b, borderColor: e2.style.stroke, label: e2.label, labelYOffset: I, datum: e2.data }, e2.key);
  })) });
};
var Z = { layers: ["grid", "layers", "slices", "dots", "legends"], maxValue: "auto", rotation: 0, curve: "linearClosed", borderWidth: 2, borderColor: { from: "color" }, gridLevels: 5, gridShape: "circular", gridLabelOffset: 16, gridLabel: function(e2) {
  var r2 = e2.id, t2 = e2.anchor, n2 = e2.animated, o2 = zt();
  return (0, import_jsx_runtime.jsx)(animated.g, { transform: n2.transform, children: (0, import_jsx_runtime.jsx)("text", { style: o2.axis.ticks.text, dominantBaseline: "central", textAnchor: t2, children: r2 }) });
}, enableDots: true, dotSize: 6, dotColor: { from: "color" }, dotBorderWidth: 0, dotBorderColor: { from: "color" }, enableDotLabel: false, dotLabel: "formattedValue", dotLabelYOffset: -12, colors: { scheme: "nivo" }, fillOpacity: 0.25, blendMode: "normal", isInteractive: true, sliceTooltip: function(r2) {
  var t2 = r2.index, n2 = r2.data, o2 = (0, import_react.useMemo)((function() {
    return n2.map((function(e2) {
      return [(0, import_jsx_runtime.jsx)(g, { color: e2.color }, e2.id), e2.id, e2.formattedValue];
    }));
  }), [n2]);
  return (0, import_jsx_runtime.jsx)(C, { title: (0, import_jsx_runtime.jsx)("strong", { children: t2 }), rows: o2 });
}, legends: [], role: "img", animate: true, motionConfig: "gentle", defs: [], fill: [] };
var $ = ["data"];
var _ = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var ee = function(t2) {
  var n2 = t2.data, o2 = t2.keys, a = t2.indexBy, l = t2.layers, d = void 0 === l ? Z.layers : l, u = t2.rotation, c = void 0 === u ? Z.rotation : u, f = t2.maxValue, h = void 0 === f ? Z.maxValue : f, x = t2.valueFormat, L = t2.curve, S = void 0 === L ? Z.curve : L, k2 = t2.margin, O2 = t2.width, C2 = t2.height, I = t2.borderWidth, M = void 0 === I ? Z.borderWidth : I, W = t2.borderColor, K = void 0 === W ? Z.borderColor : W, Y2 = t2.gridLevels, w2 = void 0 === Y2 ? Z.gridLevels : Y2, A = t2.gridShape, F = void 0 === A ? Z.gridShape : A, P = t2.gridLabel, E2 = void 0 === P ? Z.gridLabel : P, H2 = t2.gridLabelOffset, G2 = void 0 === H2 ? Z.gridLabelOffset : H2, R2 = t2.enableDots, q2 = void 0 === R2 ? Z.enableDots : R2, N2 = t2.dotSymbol, _2 = t2.dotSize, ee2 = void 0 === _2 ? Z.dotSize : _2, re2 = t2.dotColor, te2 = void 0 === re2 ? Z.dotColor : re2, ne = t2.dotBorderWidth, oe = void 0 === ne ? Z.dotBorderWidth : ne, ie = t2.dotBorderColor, ae = void 0 === ie ? Z.dotBorderColor : ie, le = t2.enableDotLabel, de = void 0 === le ? Z.enableDotLabel : le, ue = t2.dotLabel, ce = void 0 === ue ? Z.dotLabel : ue, se = t2.dotLabelYOffset, fe = void 0 === se ? Z.dotLabelYOffset : se, me = t2.colors, ge = void 0 === me ? Z.colors : me, ve = t2.fillOpacity, ye = void 0 === ve ? Z.fillOpacity : ve, he = t2.blendMode, pe = void 0 === he ? Z.blendMode : he, be = t2.isInteractive, xe = void 0 === be ? Z.isInteractive : be, Be = t2.sliceTooltip, Le = void 0 === Be ? Z.sliceTooltip : Be, Se = t2.legends, ke = void 0 === Se ? Z.legends : Se, Oe = t2.role, Ce = t2.ariaLabel, Ie = t2.ariaLabelledBy, Me = t2.ariaDescribedBy, We2 = t2.defs, Ke = void 0 === We2 ? Z.defs : We2, Ve = t2.fill, De = void 0 === Ve ? Z.fill : Ve, Ye = wt(O2, C2, k2), we = Ye.margin, Ae = Ye.innerWidth, Fe = Ye.innerHeight, Pe = Ye.outerWidth, Xe2 = Ye.outerHeight, ze = (function(r2) {
    var t3 = r2.data, n3 = r2.keys, o3 = r2.indexBy, i2 = r2.rotationDegrees, a2 = r2.maxValue, l2 = r2.valueFormat, d2 = r2.curve, u2 = r2.width, c2 = r2.height, f2 = r2.colors, h2 = void 0 === f2 ? Z.colors : f2, p = r2.legends, b = r2.defs, x2 = r2.fill, B = Wn(o3), L2 = (0, import_react.useMemo)((function() {
      return t3.map(B);
    }), [t3, B]), S2 = Ot(l2), k3 = Kt(i2), O3 = pr(h2, "key"), C3 = (0, import_react.useMemo)((function() {
      return n3.reduce((function(e2, r3, t4) {
        return e2[r3] = O3({ key: r3, index: t4 }), e2;
      }), {});
    }), [n3, O3]), I2 = (0, import_react.useMemo)((function() {
      var e2 = n3.map((function(e3) {
        return { key: e3, color: C3[e3], data: t3, fill: null };
      })), r3 = In(b, e2, x2), o4 = e2.reduce((function(e3, r4) {
        var t4 = r4.key, n4 = r4.fill;
        return e3[t4] = n4, e3;
      }), {});
      return { boundDefs: r3, fillByKey: o4 };
    }), [n3, t3, b, x2, C3]), M2 = I2.boundDefs, W2 = I2.fillByKey, K2 = (0, import_react.useMemo)((function() {
      var e2 = t3.reduce((function(e3, r4) {
        return [].concat(e3, n3.map((function(e4) {
          return r4[e4];
        })));
      }), []), r3 = "auto" !== a2 ? a2 : Math.max.apply(Math, e2), o4 = Math.min(u2, c2) / 2;
      return { radius: o4, radiusScale: linear().range([0, o4]).domain([0, r3]), centerX: u2 / 2, centerY: c2 / 2, angleStep: 2 * Math.PI / t3.length };
    }), [n3, t3, a2, u2, c2]), D2 = K2.radius, Y3 = K2.radiusScale, w3 = K2.centerX, A2 = K2.centerY, F2 = K2.angleStep, P2 = bt(d2), T2 = (0, import_react.useMemo)((function() {
      return { data: t3, keys: n3, indices: L2, colorByKey: C3, centerX: w3, centerY: A2, radiusScale: Y3, angleStep: F2 };
    }), [t3, n3, L2, C3, w3, A2, Y3, F2]), E3 = (0, import_react.useMemo)((function() {
      return n3.map((function(e2) {
        return { id: e2, label: e2, color: C3[e2] };
      }));
    }), [n3, C3]), H3 = (0, import_react.useMemo)((function() {
      return p.map((function(e2) {
        var r3 = e2.data, t4 = j(e2, $), n4 = null == r3 ? void 0 : r3.map((function(e3) {
          return z({}, E3.find((function(r4) {
            return r4.id === e3.id;
          })) || {}, e3);
        }));
        return z({}, t4, { data: n4 || E3 });
      }));
    }), [p, E3]);
    return { getIndex: B, indices: L2, formatValue: S2, colorByKey: C3, fillByKey: W2, boundDefs: M2, rotation: k3, radius: D2, radiusScale: Y3, centerX: w3, centerY: A2, angleStep: F2, curveFactory: P2, legendData: E3, boundLegends: H3, customLayerProps: T2 };
  })({ data: n2, keys: o2, indexBy: a, rotationDegrees: c, maxValue: h, valueFormat: x, curve: S, width: Ae, height: Fe, colors: ge, legends: ke, defs: Ke, fill: De }), je = ze.getIndex, Te = ze.indices, Ee = ze.formatValue, He = ze.colorByKey, Ge = ze.fillByKey, Re = ze.boundDefs, qe = ze.rotation, Je = ze.radius, Ne = ze.radiusScale, Qe = ze.centerX, Ue = ze.centerY, Ze = ze.angleStep, $e = ze.curveFactory, _e = ze.boundLegends, er = ze.customLayerProps, rr = { grid: null, layers: null, slices: null, dots: null, legends: null };
  return d.includes("grid") && (rr.grid = (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + Qe + ", " + Ue + ")", children: (0, import_jsx_runtime.jsx)(J, { levels: w2, shape: F, radius: Je, rotation: qe, angleStep: Ze, indices: Te, label: E2, labelOffset: G2 }) }, "grid")), d.includes("layers") && (rr.layers = (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + Qe + ", " + Ue + ")", children: o2.map((function(e2) {
    return (0, import_jsx_runtime.jsx)(T, { data: n2, item: e2, colorByKey: He, fillByKey: Ge, radiusScale: Ne, rotation: qe, angleStep: Ze, curveFactory: $e, borderWidth: M, borderColor: K, fillOpacity: ye, blendMode: pe }, e2);
  })) }, "layers")), d.includes("slices") && xe && (rr.slices = (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + Qe + ", " + Ue + ")", children: (0, import_jsx_runtime.jsx)(Q, { data: n2, keys: o2, getIndex: je, formatValue: Ee, colorByKey: He, radius: Je, rotation: qe, angleStep: Ze, tooltip: Le }) }, "slices")), d.includes("dots") && q2 && (rr.dots = (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + Qe + ", " + Ue + ")", children: (0, import_jsx_runtime.jsx)(U, { data: n2, keys: o2, getIndex: je, radiusScale: Ne, rotation: qe, angleStep: Ze, symbol: N2, size: ee2, colorByKey: He, color: te2, borderWidth: oe, borderColor: ae, enableLabel: de, label: ce, formatValue: Ee, labelYOffset: fe }) }, "dots")), d.includes("legends") && (rr.legends = (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: _e.map((function(e2, r2) {
    return (0, import_jsx_runtime.jsx)(O, z({}, e2, { containerWidth: O2, containerHeight: C2 }), r2);
  })) }, "legends")), (0, import_jsx_runtime.jsx)(gn, { defs: Re, width: Pe, height: Xe2, margin: we, role: Oe, ariaLabel: Ce, ariaLabelledBy: Ie, ariaDescribedBy: Me, children: d.map((function(e2, t3) {
    var n3;
    return "function" == typeof e2 ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: (0, import_react.createElement)(e2, er) }, t3) : null != (n3 = null == rr ? void 0 : rr[e2]) ? n3 : null;
  })) });
};
var re = function(e2) {
  var r2 = e2.isInteractive, t2 = void 0 === r2 ? Z.isInteractive : r2, n2 = e2.animate, o2 = void 0 === n2 ? Z.animate : n2, i2 = e2.motionConfig, a = void 0 === i2 ? Z.motionConfig : i2, l = e2.theme, d = e2.renderWrapper, u = j(e2, _);
  return (0, import_jsx_runtime.jsx)(St, { animate: o2, isInteractive: t2, motionConfig: a, renderWrapper: d, theme: l, children: (0, import_jsx_runtime.jsx)(ee, z({ isInteractive: t2 }, u)) });
};
var te = function(e2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(r2) {
    var t2 = r2.width, n2 = r2.height;
    return (0, import_jsx_runtime.jsx)(re, z({ width: t2, height: n2 }, e2));
  } });
};
export {
  re as Radar,
  U as RadarDots,
  te as ResponsiveRadar,
  Z as svgDefaultProps
};
//# sourceMappingURL=@nivo_radar.js.map
