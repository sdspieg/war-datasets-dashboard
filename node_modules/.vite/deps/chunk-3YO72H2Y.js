import {
  ascending_default,
  basisClosed_default,
  basisOpen_default,
  basis_default,
  bundle_default,
  cardinalClosed_default,
  cardinalOpen_default,
  cardinal_default,
  catmullRomClosed_default,
  catmullRomOpen_default,
  catmullRom_default,
  cubehelix,
  cubehelixLong,
  descending_default,
  diverging,
  diverging_default,
  expand_default,
  format,
  insideOut_default,
  linear,
  linearClosed_default,
  linear_default,
  monotoneX,
  monotoneY,
  natural_default,
  none_default,
  none_default2,
  ordinal,
  quantize,
  require_SetCache,
  require_Stack,
  require_arrayIncludes,
  require_arrayIncludesWith,
  require_arrayMap,
  require_assignValue,
  require_baseAssignValue,
  require_baseFor,
  require_baseGet,
  require_baseRest,
  require_baseUnary,
  require_cacheHas,
  require_castPath,
  require_cloneBuffer,
  require_cloneTypedArray,
  require_copyArray,
  require_copyObject,
  require_eq,
  require_flatRest,
  require_get,
  require_hasIn,
  require_initCloneObject,
  require_isArguments,
  require_isArray,
  require_isArrayLike,
  require_isBuffer,
  require_isEqual,
  require_isFunction,
  require_isIndex,
  require_isIterateeCall,
  require_isObject,
  require_isObjectLike,
  require_isPlainObject,
  require_isString,
  require_isTypedArray,
  require_keysIn,
  require_last,
  require_prop_types,
  require_toKey,
  reverse_default,
  rgb,
  rgbBasis,
  sequential,
  silhouette_default,
  stepAfter,
  stepBefore,
  step_default,
  string_default,
  timeFormat,
  wiggle_default
} from "./chunk-F2U6MNST.js";
import {
  require_jsx_runtime
} from "./chunk-RLMGAKMB.js";
import {
  require_react_dom
} from "./chunk-SVG7M4VJ.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-2YIMICFJ.js";

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/merge.js
var require_merge = __commonJS({
  "node_modules/lodash/merge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module.exports = baseSet;
  }
});

// node_modules/lodash/set.js
var require_set = __commonJS({
  "node_modules/lodash/set.js"(exports, module) {
    var baseSet = require_baseSet();
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    module.exports = set;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseDifference;
  }
});

// node_modules/lodash/without.js
var require_without = __commonJS({
  "node_modules/lodash/without.js"(exports, module) {
    var baseDifference = require_baseDifference();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, values) : [];
    });
    module.exports = without;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module.exports = basePickBy;
  }
});

// node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "node_modules/lodash/_basePick.js"(exports, module) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }
    module.exports = basePick;
  }
});

// node_modules/lodash/pick.js
var require_pick = __commonJS({
  "node_modules/lodash/pick.js"(exports, module) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module.exports = pick;
  }
});

// node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs
var updateQueue = makeQueue();
var raf = (fn2) => schedule(fn2, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn2) => schedule(fn2, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn2) => schedule(fn2, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn2) => schedule(fn2, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn2) => schedule(fn2, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  const time = raf.now() + ms;
  const cancel = () => {
    const i3 = timeouts.findIndex((t4) => t4.cancel == cancel);
    if (~i3)
      timeouts.splice(i3, 1);
    pendingCount -= ~i3 ? 1 : 0;
  };
  const timeout = { time, handler, cancel };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t4) => t4.time > time) || ~timeouts.length);
raf.cancel = (fn2) => {
  onStartQueue.delete(fn2);
  onFrameQueue.delete(fn2);
  onFinishQueue.delete(fn2);
  updateQueue.delete(fn2);
  writeQueue.delete(fn2);
};
raf.sync = (fn2) => {
  sync = true;
  raf.batchedUpdates(fn2);
  sync = false;
};
raf.throttle = (fn2) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn2(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn2;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  (() => {
  })
);
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn2) => fn2();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn(
      "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
    );
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn2, queue) {
  if (sync) {
    queue.delete(fn2);
    fn2(0);
  } else {
    queue.add(fn2);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  const prevTs = ts;
  ts = raf.now();
  const count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t4) => t4.handler());
    pendingCount -= count;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn2) {
      pendingCount += current == next && !next.has(fn2) ? 1 : 0;
      next.add(fn2);
    },
    delete(fn2) {
      pendingCount -= current == next && next.has(fn2) ? 1 : 0;
      return next.delete(fn2);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn2) => fn2(arg) && next.add(fn2));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e4) {
      raf.catch(e4);
    }
  });
}

// node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var globals_exports = {};
__export(globals_exports, {
  assign: () => assign,
  colors: () => colors,
  createStringInterpolator: () => createStringInterpolator,
  skipAnimation: () => skipAnimation,
  to: () => to,
  willAdvance: () => willAdvance
});
function noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
var is = {
  arr: Array.isArray,
  obj: (a2) => !!a2 && a2.constructor.name === "Object",
  fun: (a2) => typeof a2 === "function",
  str: (a2) => typeof a2 === "string",
  num: (a2) => typeof a2 === "number",
  und: (a2) => a2 === void 0
};
function isEqual(a2, b3) {
  if (is.arr(a2)) {
    if (!is.arr(b3) || a2.length !== b3.length)
      return false;
    for (let i3 = 0; i3 < a2.length; i3++) {
      if (a2[i3] !== b3[i3])
        return false;
    }
    return true;
  }
  return a2 === b3;
}
var each = (obj, fn2) => obj.forEach(fn2);
function eachProp(obj, fn2, ctx2) {
  if (is.arr(obj)) {
    for (let i3 = 0; i3 < obj.length; i3++) {
      fn2.call(ctx2, obj[i3], `${i3}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn2.call(ctx2, obj[key], key);
    }
  }
}
var toArray = (a2) => is.und(a2) ? [] : is.arr(a2) ? a2 : [a2];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn2) => fn2(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var createStringInterpolator;
var to;
var colors = null;
var skipAnimation = false;
var willAdvance = noop;
var assign = (globals) => {
  if (globals.to)
    to = globals.to;
  if (globals.now)
    raf.now = globals.now;
  if (globals.colors !== void 0)
    colors = globals.colors;
  if (globals.skipAnimation != null)
    skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator)
    createStringInterpolator = globals.createStringInterpolator;
  if (globals.requestAnimationFrame)
    raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates)
    raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance)
    willAdvance = globals.willAdvance;
  if (globals.frameLoop)
    raf.frameLoop = globals.frameLoop;
};
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  /** Advance all animations by the given time. */
  advance,
  /** Call this when an animation's priority changes. */
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   * ☠️ Never call this from within the frameloop.
   */
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(
    findIndex(currentFrame, (other) => other.priority > animation.priority),
    0,
    animation
  );
}
function advance(dt2) {
  const nextFrame = prevFrame;
  for (let i3 = 0; i3 < currentFrame.length; i3++) {
    const animation = currentFrame[i3];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt2);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}
var clamp = (min, max, v4) => Math.min(Math.max(v4, min), max);
var colors2 = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb2 = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp(
  "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
);
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors && colors[color] !== void 0) {
    return colors[color];
  }
  if (match = rgb2.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p3, q2, t4) {
  if (t4 < 0)
    t4 += 1;
  if (t4 > 1)
    t4 -= 1;
  if (t4 < 1 / 6)
    return p3 + (q2 - p3) * 6 * t4;
  if (t4 < 1 / 2)
    return q2;
  if (t4 < 2 / 3)
    return p3 + (q2 - p3) * (2 / 3 - t4) * 6;
  return p3;
}
function hslToRgb(h2, s3, l3) {
  const q2 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
  const p3 = 2 * l3 - q2;
  const r3 = hue2rgb(p3, q2, h2 + 1 / 3);
  const g3 = hue2rgb(p3, q2, h2);
  const b3 = hue2rgb(p3, q2, h2 - 1 / 3);
  return Math.round(r3 * 255) << 24 | Math.round(g3 * 255) << 16 | Math.round(b3 * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  const r3 = (int32Color & 4278190080) >>> 24;
  const g3 = (int32Color & 16711680) >>> 16;
  const b3 = (int32Color & 65280) >>> 8;
  const a2 = (int32Color & 255) / 255;
  return `rgba(${r3}, ${g3}, ${b3}, ${a2})`;
}
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t4) => t4);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range2],
      inputRange[range2 + 1],
      outputRange[range2],
      outputRange[range2 + 1],
      easing,
      extrapolateLeft,
      extrapolateRight,
      config2.map
    );
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i3 = 1; i3 < inputRange.length - 1; ++i3)
    if (inputRange[i3] >= input)
      break;
  return i3 - 1;
}
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x3) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x3 < 1 / d1) {
    return n1 * x3 * x3;
  } else if (x3 < 2 / d1) {
    return n1 * (x3 -= 1.5 / d1) * x3 + 0.75;
  } else if (x3 < 2.5 / d1) {
    return n1 * (x3 -= 2.25 / d1) * x3 + 0.9375;
  } else {
    return n1 * (x3 -= 2.625 / d1) * x3 + 0.984375;
  }
};
var easings = {
  linear: (x3) => x3,
  easeInQuad: (x3) => x3 * x3,
  easeOutQuad: (x3) => 1 - (1 - x3) * (1 - x3),
  easeInOutQuad: (x3) => x3 < 0.5 ? 2 * x3 * x3 : 1 - Math.pow(-2 * x3 + 2, 2) / 2,
  easeInCubic: (x3) => x3 * x3 * x3,
  easeOutCubic: (x3) => 1 - Math.pow(1 - x3, 3),
  easeInOutCubic: (x3) => x3 < 0.5 ? 4 * x3 * x3 * x3 : 1 - Math.pow(-2 * x3 + 2, 3) / 2,
  easeInQuart: (x3) => x3 * x3 * x3 * x3,
  easeOutQuart: (x3) => 1 - Math.pow(1 - x3, 4),
  easeInOutQuart: (x3) => x3 < 0.5 ? 8 * x3 * x3 * x3 * x3 : 1 - Math.pow(-2 * x3 + 2, 4) / 2,
  easeInQuint: (x3) => x3 * x3 * x3 * x3 * x3,
  easeOutQuint: (x3) => 1 - Math.pow(1 - x3, 5),
  easeInOutQuint: (x3) => x3 < 0.5 ? 16 * x3 * x3 * x3 * x3 * x3 : 1 - Math.pow(-2 * x3 + 2, 5) / 2,
  easeInSine: (x3) => 1 - Math.cos(x3 * Math.PI / 2),
  easeOutSine: (x3) => Math.sin(x3 * Math.PI / 2),
  easeInOutSine: (x3) => -(Math.cos(Math.PI * x3) - 1) / 2,
  easeInExpo: (x3) => x3 === 0 ? 0 : Math.pow(2, 10 * x3 - 10),
  easeOutExpo: (x3) => x3 === 1 ? 1 : 1 - Math.pow(2, -10 * x3),
  easeInOutExpo: (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : x3 < 0.5 ? Math.pow(2, 20 * x3 - 10) / 2 : (2 - Math.pow(2, -20 * x3 + 10)) / 2,
  easeInCirc: (x3) => 1 - Math.sqrt(1 - Math.pow(x3, 2)),
  easeOutCirc: (x3) => Math.sqrt(1 - Math.pow(x3 - 1, 2)),
  easeInOutCirc: (x3) => x3 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x3, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x3 + 2, 2)) + 1) / 2,
  easeInBack: (x3) => c3 * x3 * x3 * x3 - c1 * x3 * x3,
  easeOutBack: (x3) => 1 + c3 * Math.pow(x3 - 1, 3) + c1 * Math.pow(x3 - 1, 2),
  easeInOutBack: (x3) => x3 < 0.5 ? Math.pow(2 * x3, 2) * ((c2 + 1) * 2 * x3 - c2) / 2 : (Math.pow(2 * x3 - 2, 2) * ((c2 + 1) * (x3 * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : -Math.pow(2, 10 * x3 - 10) * Math.sin((x3 * 10 - 10.75) * c4),
  easeOutElastic: (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : Math.pow(2, -10 * x3) * Math.sin((x3 * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : x3 < 0.5 ? -(Math.pow(2, 20 * x3 - 10) * Math.sin((20 * x3 - 11.125) * c5)) / 2 : Math.pow(2, -20 * x3 + 10) * Math.sin((20 * x3 - 11.125) * c5) / 2 + 1,
  easeInBounce: (x3) => 1 - bounceOut(1 - x3),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x3) => x3 < 0.5 ? (1 - bounceOut(1 - 2 * x3)) / 2 : (1 + bounceOut(2 * x3 - 1)) / 2,
  steps
};
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer2, event) {
  if (observer2.eventObserved) {
    observer2.eventObserved(event);
  } else {
    observer2(event);
  }
}
function callFluidObservers(target, event) {
  const observers = target[$observers];
  if (observers) {
    observers.forEach((observer2) => {
      callFluidObserver(observer2, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer2) {
  if (target[$get]) {
    let observers = target[$observers];
    if (!observers) {
      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer2)) {
      observers.add(observer2);
      if (target.observerAdded) {
        target.observerAdded(observers.size, observer2);
      }
    }
  }
  return observer2;
}
function removeFluidObserver(target, observer2) {
  const observers = target[$observers];
  if (observers && observers.has(observer2)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer2);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count, observer2);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (value2) {
      return value2;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};
var namedColorRegex;
var rgbaRound = (_, p1, p22, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p22)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator2 = (config2) => {
  if (!namedColorRegex)
    namedColorRegex = colors ? (
      // match color names, ignore partial matches
      new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
    ) : (
      // never match
      /^\b$/
    );
  const output = config2.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map(
    (_, i3) => keyframes.map((values) => {
      if (!(i3 in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i3];
    })
  );
  const interpolators = outputRanges.map(
    (output2) => createInterpolator({ ...config2, output: output2 })
  );
  return (input) => {
    var _a;
    const missingUnit = !unitRegex.test(output[0]) && ((_a = output.find((value) => unitRegex.test(value))) == null ? void 0 : _a.replace(numberRegex, ""));
    let i3 = 0;
    return output[0].replace(
      numberRegex,
      () => `${interpolators[i3++](input)}${missingUnit || ""}`
    ).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn2) => {
  const func = fn2;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(
    `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(
    `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
}
var useIsomorphicLayoutEffect = isSSR() ? import_react4.useEffect : import_react4.useLayoutEffect;
var useIsMounted = () => {
  const isMounted = (0, import_react3.useRef)(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};
function useForceUpdate() {
  const update3 = (0, import_react2.useState)()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update3(Math.random());
    }
  };
}
function useMemoOne(getResult, inputs) {
  const [initial] = (0, import_react5.useState)(
    () => ({
      inputs,
      result: getResult()
    })
  );
  const committed = (0, import_react5.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(
      inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
    );
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0, import_react5.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i3 = 0; i3 < next.length; i3++) {
    if (next[i3] !== prev[i3]) {
      return false;
    }
  }
  return true;
}
var useOnce = (effect) => (0, import_react6.useEffect)(effect, emptyDeps);
var emptyDeps = [];
function usePrev(value) {
  const prevRef = (0, import_react7.useRef)();
  (0, import_react7.useEffect)(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}

// node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
var import_react10 = __toESM(require_react(), 1);

// node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs
var React = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    setAnimated(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;
    this.durationProgress = 0;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  /** @internal */
  static create(value) {
    return new AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const { done } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  /** @internal */
  static create(value) {
    return new AnimatedString(value);
  }
  getValue() {
    const value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = { dependencies: null };
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated2) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node) => node.reset());
    }
  }
  /** Create a payload set. */
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node) => this.add(node));
    }
  }
};
var AnimatedArray = class extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  /** @internal */
  static create(source) {
    return new AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i3) => node.setValue(source[i3])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}
function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}
var withAnimated = (Component, host2) => {
  const hasInstance = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
  );
  return (0, import_react9.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0, import_react9.useRef)(null);
    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, import_react9.useCallback)(
      (value) => {
        instanceRef.current = updateRef(givenRef, value);
      },
      [givenRef]
    );
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0, import_react9.useRef)();
    useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          each(
            observerRef.current.deps,
            (dep) => removeFluidObserver(dep, observerRef.current)
          );
          raf.cancel(observerRef.current.update);
        }
      };
    });
    (0, import_react9.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return React.createElement(Component, { ...usedProps, ref });
  });
};
var PropsObserver = class {
  constructor(update3, deps) {
    this.update = update3;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = {
      ...props,
      style: host2.createAnimatedStyle(props.style)
    };
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref))
      ref(value);
    else
      ref.current = value;
  }
  return value;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: applyAnimatedValues2 = () => false,
  createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: applyAnimatedValues2,
    createAnimatedStyle,
    getComponentProps
  };
  const animated2 = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated2[key] = animated2(Component);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

// node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
var React2 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var React22 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to22 = getForwardProps(props);
  if (to22) {
    const out = { to: to22 };
    eachProp(props, (val, key) => key in to22 || (out[key] = val));
    return out;
  }
  return { ...props };
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _ in props)
    return true;
  return false;
}
function isAsyncTo(to22) {
  return is.fun(to22) || is.arr(to22) && is.obj(to22[0]);
}
function detachRefs(ctrl, ref) {
  var _a;
  (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
  ref == null ? void 0 : ref.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  var _a;
  if (ref && ctrl.ref !== ref) {
    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}
var config = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
};
var defaults = {
  ...config.default,
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
};
var AnimationConfig = class {
  constructor() {
    this.velocity = 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = { ...defaultConfig };
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = { ...defaultConfig, ...newConfig };
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let { frequency, damping } = config2;
  const { mass } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
  return new Promise((resolve, reject) => {
    let delay;
    let timeout;
    let cancel = matchProp(props.cancel ?? (defaultProps == null ? void 0 : defaultProps.cancel), key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps == null ? void 0 : defaultProps.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals_exports.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start({ ...props, callId, cancel }, resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
  target.get(),
  results.every((result) => result.finished)
);
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});
function runAsync(to22, props, state, target) {
  const { callId, parentId, onRest } = props;
  const { asyncTo: prevTo, promise: prevPromise } = state;
  if (!parentId && to22 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to22;
    const defaultProps = getDefaultProps(
      props,
      (value, key) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        key === "onRest" ? void 0 : value
      )
    );
    let preventBail;
    let bail;
    const bailPromise = new Promise(
      (resolve, reject) => (preventBail = resolve, bail = reject)
    );
    const bailIfEnded = (bailSignal) => {
      const bailResult = (
        // The `cancel` prop or `stop` method was used.
        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
        callId !== state.asyncId && getFinishedResult(target, false)
      );
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals_exports.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals_exports.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to22)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to22);
      } else {
        animating = Promise.resolve(to22(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t4) => t4.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};
var isFrameValue = (value) => value instanceof FrameValue;
var nextId = 1;
var FrameValue = class extends FluidValue {
  constructor() {
    super(...arguments);
    this.id = nextId++;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  /** Get the current value */
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...args) {
    return globals_exports.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...args) {
    deprecateInterpolate();
    return globals_exports.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.animation = new Animation();
    this.defaultProps = {};
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._pendingCalls = /* @__PURE__ */ new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return hasAnimated(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return isAnimating(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return isPaused(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(dt2) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let { toValues } = anim;
    const { config: config2 } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i3) => {
      if (node2.done)
        return;
      const to22 = (
        // Animated strings always go from 0 to 1.
        node2.constructor == AnimatedString ? 1 : payload ? payload[i3].lastPosition : toValues[i3]
      );
      let finished = anim.immediate;
      let position = to22;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt2;
        const from = anim.fromValues[i3];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i3] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to22 ? 5e-3 : Math.min(1, Math.abs(to22 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p3 = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt2;
              }
            }
            p3 = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p3 = p3 > 1 ? 1 : p3 < 0 ? 0 : p3;
            node2.durationProgress = p3;
          }
          position = from + config2.easing(p3) * (to22 - from);
          velocity = (position - node2.lastPosition) / dt2;
          finished = p3 == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e4 = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e4);
          finished = Math.abs(node2.lastPosition - position) <= precision;
          velocity = v0 * e4;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to22 ? node2.v0 > 0 : from < to22;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt2 / step);
          for (let n3 = 0; n3 < numSteps; ++n3) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to22 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to22 || position > to22 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to22;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to22);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position = position + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i3].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  /** Set the current value, while stopping the current animation */
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: true });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: false });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (isAnimating(this)) {
      const { to: to22, config: config2 } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to22, false);
        }
        this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to22, arg2) {
    let queue;
    if (!is.und(to22)) {
      queue = [is.obj(to22) ? to22 : { ...arg2, to: to22 }];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(
      queue.map((props) => {
        const up = this._update(props);
        return up;
      })
    ).then((results) => getCombinedResult(this, results));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(cancel) {
    const { to: to22 } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to22, cancel));
    return this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: true });
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(props) {
    const key = this.key || "";
    let { to: to22, from } = props;
    to22 = is.obj(to22) ? to22[key] : to22;
    if (to22 == null || isAsyncTo(to22)) {
      to22 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = { to: to22, from };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to22, from] = [from, to22];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to22);
      }
    }
    return range;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...props }, isLoop) {
    const { key, defaultProps } = this;
    if (props.default)
      Object.assign(
        defaultProps,
        getDefaultProps(
          props,
          (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
        )
      );
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(
              this,
              "onPause",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(
              this,
              "onResume",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  /** Merge props into the current animation */
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const { key, defaultProps, animation: anim } = this;
    const { to: prevTo, from: prevFrom } = anim;
    let { to: to22 = prevTo, from = prevFrom } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to22))) {
      to22 = from;
    }
    if (props.reverse)
      [to22, from] = [from, to22];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to22, prevTo);
    if (hasToChanged) {
      this._focus(to22);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const { config: config2 } = anim;
    const { decay, velocity } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(
        config2,
        callProp(props.config, key),
        // Avoid calling the same "config" prop twice.
        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
      );
    }
    let node = getAnimated(this);
    if (!node || is.und(to22)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key)
    );
    const value = reset ? from : this.get();
    const goal = computeGoal(to22);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to22);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(
            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
          );
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to22);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to22) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const { onRest } = anim;
        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            var _a;
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              (_a = anim.onStart) == null ? void 0 : _a.call(anim, result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const { to: to22 } = this.animation;
    if (hasFluidValue(to22)) {
      addFluidObserver(to22, this);
      if (isFrameValue(to22)) {
        priority2 = to22.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const { to: to22 } = this.animation;
    if (hasFluidValue(to22)) {
      removeFluidObserver(to22, this);
    }
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(
        this,
        "onStart",
        getFinishedResult(this, checkFinished(this, anim.to)),
        this
      );
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals_exports.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to22) {
  const goal = computeGoal(to22);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to22 = props.to) {
  const loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate({
      ...props,
      loop: loop2,
      // Avoid updating default props when looping.
      default: false,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !reverse || isAsyncTo(to22) ? to22 : void 0,
      // Ignore the "from" prop except on reset.
      from: reset ? props.from : void 0,
      reset,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...overrides
    });
  }
}
function createUpdate(props) {
  const { to: to22, from } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to22))
    findDefined(to22, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update22 = createUpdate(props);
  if (is.und(update22.default)) {
    update22.default = getDefaultProps(update22);
  }
  return update22;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  var _a, _b, _c, _d;
  (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);
  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId2 = 1;
var Controller = class {
  constructor(props, flush3) {
    this.id = nextId2++;
    this.springs = {};
    this.queue = [];
    this._lastAsyncId = 0;
    this._active = /* @__PURE__ */ new Set();
    this._changed = /* @__PURE__ */ new Set();
    this._started = false;
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush3) {
      this._flush = flush3;
    }
    if (props) {
      this.start({ default: true, ...props });
    }
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  /** Get the current values of our springs */
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  /** Set the current values without animating. */
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  /** Push an update onto the queue of each value. */
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(props) {
    let { queue } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  /** @internal */
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  /** Freeze the active animation in time */
  pause(keys) {
    if (is.und(keys)) {
      this.start({ pause: true });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(keys) {
    if (is.und(keys)) {
      this.start({ pause: false });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart, onChange, onRest } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
    (results) => getCombinedResult(ctrl, results)
  );
}
async function flushUpdate(ctrl, props, isLoop) {
  const { keys, to: to22, from, loop: loop2, onRest, onResolve } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to22 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to22) || is.fun(to22) ? to22 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({ finished, cancelled }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map(
    (key) => ctrl.springs[key].start(props)
  );
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(
      scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(
                runAsync(
                  asyncTo,
                  props2,
                  state,
                  ctrl
                )
              );
            }
          }
        }
      })
    );
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to22);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = { ...ctrl.springs };
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = { ...props2, to: void 0 };
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
var SpringContext = ({
  children,
  ...props
}) => {
  const inherited = (0, import_react11.useContext)(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
  const { Provider } = ctx;
  return React2.createElement(Provider, { value: props }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, React2.createContext(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i3) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update22 = _getProps(props, ctrl, i3);
        if (update22) {
          results.push(ctrl.start(update22));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i3 = current.indexOf(ctrl);
    if (~i3)
      current.splice(i3, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each(current, (ctrl, i3) => {
      const update22 = is.fun(values) ? values(i3, ctrl) : values;
      if (update22) {
        ctrl.set(update22);
      }
    });
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i3) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update22 = this._getProps(props, ctrl, i3);
        if (update22) {
          results.push(ctrl.start(update22));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i3) => ctrl.update(this._getProps(props, ctrl, i3)));
    return this;
  };
  const _getProps = function(arg, ctrl, index) {
    return is.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = (0, import_react10.useMemo)(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const layoutId = (0, import_react10.useRef)(0);
  const forceUpdate = useForceUpdate();
  const state = (0, import_react10.useMemo)(
    () => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }),
    []
  );
  const ctrls = (0, import_react10.useRef)([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  (0, import_react10.useMemo)(() => {
    each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0, import_react10.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      const ctrl = ctrls.current[i3] || (ctrls.current[i3] = new Controller(null, state.flush));
      const update22 = propsFn ? propsFn(i3, ctrl) : props[i3];
      if (update22) {
        updates[i3] = declareUpdate(update22);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i3) => getSprings(ctrl, updates[i3]));
  const context = (0, import_react10.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const { queue } = state;
    if (queue.length) {
      state.queue = [];
      each(queue, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i3) => {
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext) {
        ctrl.start({ default: context });
      }
      const update22 = updates[i3];
      if (update22) {
        replaceRef(ctrl, update22.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update22);
        } else {
          ctrl.start(update22);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x3) => ({ ...x3 }));
  return ref ? [values, ref] : values;
}
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref] = useSprings(
    1,
    isFn ? props : [props],
    isFn ? deps || [] : deps
  );
  return isFn || arguments.length == 2 ? [values, ref] : values;
}
function useTransition(data, props, deps) {
  const propsFn = is.fun(props) && props;
  const {
    reset,
    sort,
    trail = 0,
    expires = true,
    exitBeforeEnter = false,
    onDestroyed,
    ref: propsRef,
    config: propsConfig
  } = propsFn ? propsFn() : props;
  const ref = (0, import_react13.useMemo)(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const items = toArray(data);
  const transitions = [];
  const usedTransitions = (0, import_react13.useRef)(null);
  const prevTransitions = reset ? null : usedTransitions.current;
  useIsomorphicLayoutEffect(() => {
    usedTransitions.current = transitions;
  });
  useOnce(() => {
    each(transitions, (t4) => {
      ref == null ? void 0 : ref.add(t4.ctrl);
      t4.ctrl.ref = ref;
    });
    return () => {
      each(usedTransitions.current, (t4) => {
        if (t4.expired) {
          clearTimeout(t4.expirationId);
        }
        detachRefs(t4.ctrl, ref);
        t4.ctrl.stop(true);
      });
    };
  });
  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
  const expired = reset && usedTransitions.current || [];
  useIsomorphicLayoutEffect(
    () => each(expired, ({ ctrl, item, key }) => {
      detachRefs(ctrl, ref);
      callProp(onDestroyed, item, key);
    })
  );
  const reused = [];
  if (prevTransitions)
    each(prevTransitions, (t4, i3) => {
      if (t4.expired) {
        clearTimeout(t4.expirationId);
        expired.push(t4);
      } else {
        i3 = reused[i3] = keys.indexOf(t4.key);
        if (~i3)
          transitions[i3] = t4;
      }
    });
  each(items, (item, i3) => {
    if (!transitions[i3]) {
      transitions[i3] = {
        key: keys[i3],
        item,
        phase: "mount",
        ctrl: new Controller()
      };
      transitions[i3].ctrl.item = item;
    }
  });
  if (reused.length) {
    let i3 = -1;
    const { leave } = propsFn ? propsFn() : props;
    each(reused, (keyIndex, prevIndex) => {
      const t4 = prevTransitions[prevIndex];
      if (~keyIndex) {
        i3 = transitions.indexOf(t4);
        transitions[i3] = { ...t4, item: items[keyIndex] };
      } else if (leave) {
        transitions.splice(++i3, 0, t4);
      }
    });
  }
  if (is.fun(sort)) {
    transitions.sort((a2, b3) => sort(a2.item, b3.item));
  }
  let delay = -trail;
  const forceUpdate = useForceUpdate();
  const defaultProps = getDefaultProps(props);
  const changes = /* @__PURE__ */ new Map();
  const exitingTransitions = (0, import_react13.useRef)(/* @__PURE__ */ new Map());
  const forceChange = (0, import_react13.useRef)(false);
  each(transitions, (t4, i3) => {
    const key = t4.key;
    const prevPhase = t4.phase;
    const p3 = propsFn ? propsFn() : props;
    let to22;
    let phase;
    const propsDelay = callProp(p3.delay || 0, key);
    if (prevPhase == "mount") {
      to22 = p3.enter;
      phase = "enter";
    } else {
      const isLeave = keys.indexOf(key) < 0;
      if (prevPhase != "leave") {
        if (isLeave) {
          to22 = p3.leave;
          phase = "leave";
        } else if (to22 = p3.update) {
          phase = "update";
        } else
          return;
      } else if (!isLeave) {
        to22 = p3.enter;
        phase = "enter";
      } else
        return;
    }
    to22 = callProp(to22, t4.item, i3);
    to22 = is.obj(to22) ? inferTo(to22) : { to: to22 };
    if (!to22.config) {
      const config2 = propsConfig || defaultProps.config;
      to22.config = callProp(config2, t4.item, i3, phase);
    }
    delay += trail;
    const payload = {
      ...defaultProps,
      // we need to add our props.delay value you here.
      delay: propsDelay + delay,
      ref: propsRef,
      immediate: p3.immediate,
      // This prevents implied resets.
      reset: false,
      // Merge any phase-specific props.
      ...to22
    };
    if (phase == "enter" && is.und(payload.from)) {
      const p22 = propsFn ? propsFn() : props;
      const from = is.und(p22.initial) || prevTransitions ? p22.from : p22.initial;
      payload.from = callProp(from, t4.item, i3);
    }
    const { onResolve } = payload;
    payload.onResolve = (result) => {
      callProp(onResolve, result);
      const transitions2 = usedTransitions.current;
      const t22 = transitions2.find((t32) => t32.key === key);
      if (!t22)
        return;
      if (result.cancelled && t22.phase != "update") {
        return;
      }
      if (t22.ctrl.idle) {
        const idle = transitions2.every((t32) => t32.ctrl.idle);
        if (t22.phase == "leave") {
          const expiry = callProp(expires, t22.item);
          if (expiry !== false) {
            const expiryMs = expiry === true ? 0 : expiry;
            t22.expired = true;
            if (!idle && expiryMs > 0) {
              if (expiryMs <= 2147483647)
                t22.expirationId = setTimeout(forceUpdate, expiryMs);
              return;
            }
          }
        }
        if (idle && transitions2.some((t32) => t32.expired)) {
          exitingTransitions.current.delete(t22);
          if (exitBeforeEnter) {
            forceChange.current = true;
          }
          forceUpdate();
        }
      }
    };
    const springs = getSprings(t4.ctrl, payload);
    if (phase === "leave" && exitBeforeEnter) {
      exitingTransitions.current.set(t4, { phase, springs, payload });
    } else {
      changes.set(t4, { phase, springs, payload });
    }
  });
  const context = (0, import_react13.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect(() => {
    if (hasContext) {
      each(transitions, (t4) => {
        t4.ctrl.start({ default: context });
      });
    }
  }, [context]);
  each(changes, (_, t4) => {
    if (exitingTransitions.current.size) {
      const ind = transitions.findIndex((state) => state.key === t4.key);
      transitions.splice(ind, 1);
    }
  });
  useIsomorphicLayoutEffect(
    () => {
      each(
        exitingTransitions.current.size ? exitingTransitions.current : changes,
        ({ phase, payload }, t4) => {
          const { ctrl } = t4;
          t4.phase = phase;
          ref == null ? void 0 : ref.add(ctrl);
          if (hasContext && phase == "enter") {
            ctrl.start({ default: context });
          }
          if (payload) {
            replaceRef(ctrl, payload.ref);
            if ((ctrl.ref || ref) && !forceChange.current) {
              ctrl.update(payload);
            } else {
              ctrl.start(payload);
              if (forceChange.current) {
                forceChange.current = false;
              }
            }
          }
        }
      );
    },
    reset ? void 0 : deps
  );
  const renderTransitions = (render) => React22.createElement(React22.Fragment, null, transitions.map((t4, i3) => {
    const { springs } = changes.get(t4) || t4.ctrl;
    const elem = render({ ...springs }, t4.item, t4, i3);
    return elem && elem.type ? React22.createElement(
      elem.type,
      {
        ...elem.props,
        key: is.str(t4.key) || is.num(t4.key) ? t4.key : t4.ctrl.id,
        ref: elem.ref
      }
    ) : elem;
  }));
  return ref ? [renderTransitions, ref] : renderTransitions;
}
var nextKey = 1;
function getKeys(items, { key, keys = key }, prevTransitions) {
  if (keys === null) {
    const reused = /* @__PURE__ */ new Set();
    return items.map((item) => {
      const t4 = prevTransitions && prevTransitions.find(
        (t22) => t22.item === item && t22.phase !== "leave" && !reused.has(t22)
      );
      if (t4) {
        reused.add(t4);
        return t4.key;
      }
      return nextKey++;
    });
  }
  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);
}
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.source = source;
    this.idle = true;
    this._active = /* @__PURE__ */ new Set();
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals_exports.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  // Observe our sources only when we're observed.
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce(
        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
        0
      );
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self) {
  if (!self.idle) {
    self.idle = true;
    each(getPayload(self), (node) => {
      node.done = true;
    });
    callFluidObservers(self, {
      type: "idle",
      parent: self
    });
  }
}
var to2 = (source, ...args) => new Interpolation(source, args);
globals_exports.assign({
  createStringInterpolator: createStringInterpolator2,
  to: (source, args) => new Interpolation(source, args)
});
var update2 = frameLoop.advance;

// node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox,
    ...attributes
  } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n3) => "-" + n3.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i3) => {
    instance.setAttribute(name, values[i3]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v4) => isValueIdentity(v4, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x: x3, y: y4, z: z4, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x3 || y4 || z4) {
      inputs.push([x3 || 0, y4 || 0, z4 || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v4) => addUnit(v4, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x22, y22, z22, deg]) => [
            `rotate3d(${x22},${y22},${z22},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v4) => addUnit(v4, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i3) => {
      const arg1 = getFluidValue(input[0]);
      const [t4, id] = this.transforms[i3](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t4;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count) {
    if (count == 1)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count) {
    if (count == 0)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;

// node_modules/@nivo/tooltip/dist/nivo-tooltip.es.js
var import_react16 = __toESM(require_react());

// node_modules/@nivo/core/dist/nivo-core.es.js
var import_react15 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_merge = __toESM(require_merge());
var import_get = __toESM(require_get());
var import_set = __toESM(require_set());
var import_isString = __toESM(require_isString());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_last = __toESM(require_last());
var import_isArray = __toESM(require_isArray());

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n3 = specifier.length / 6 | 0, colors3 = new Array(n3), i3 = 0;
  while (i3 < n3) colors3[i3] = "#" + specifier.slice(i3 * 6, ++i3 * 6);
  return colors3;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t4 * (35.34 - t4 * (2381.73 - t4 * (6402.7 - t4 * (7024.72 - t4 * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t4 * (170.73 + t4 * (52.82 - t4 * (131.46 - t4 * (176.58 - t4 * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t4 * (442.36 - t4 * (2482.43 - t4 * (6167.24 - t4 * (6614.94 - t4 * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c = cubehelix();
function rainbow_default(t4) {
  if (t4 < 0 || t4 > 1) t4 -= Math.floor(t4);
  var ts2 = Math.abs(t4 - 0.5);
  c.h = 360 * t4 - 100;
  c.s = 1.5 - 1.5 * ts2;
  c.l = 0.8 - 0.9 * ts2;
  return c + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c6 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t4) {
  var x3;
  t4 = (0.5 - t4) * Math.PI;
  c6.r = 255 * (x3 = Math.sin(t4)) * x3;
  c6.g = 255 * (x3 = Math.sin(t4 + pi_1_3)) * x3;
  c6.b = 255 * (x3 = Math.sin(t4 + pi_2_3)) * x3;
  return c6 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t4 * (1172.33 - t4 * (10793.56 - t4 * (33300.12 - t4 * (38394.49 - t4 * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t4 * (557.33 + t4 * (1225.33 - t4 * (3574.96 - t4 * (1073.77 + t4 * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t4 * (3211.1 - t4 * (15327.97 - t4 * (27814 - t4 * (22569.18 - t4 * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range) {
  var n3 = range.length;
  return function(t4) {
    return range[Math.max(0, Math.min(n3 - 1, Math.floor(t4 * n3)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/@nivo/core/dist/nivo-core.es.js
var import_isFunction = __toESM(require_isFunction());
var import_without = __toESM(require_without());
var import_isPlainObject = __toESM(require_isPlainObject());
var import_pick = __toESM(require_pick());
var import_isEqual = __toESM(require_isEqual());
var Pr = { background: "transparent", text: { fontFamily: "sans-serif", fontSize: 11, fill: "#333333", outlineWidth: 0, outlineColor: "transparent", outlineOpacity: 1 }, axis: { domain: { line: { stroke: "transparent", strokeWidth: 1 } }, ticks: { line: { stroke: "#777777", strokeWidth: 1 }, text: {} }, legend: { text: { fontSize: 12 } } }, grid: { line: { stroke: "#dddddd", strokeWidth: 1 } }, legends: { hidden: { symbol: { fill: "#333333", opacity: 0.6 }, text: { fill: "#333333", opacity: 0.6 } }, text: {}, ticks: { line: { stroke: "#777777", strokeWidth: 1 }, text: { fontSize: 10 } }, title: { text: {} } }, labels: { text: {} }, markers: { lineColor: "#000000", lineStrokeWidth: 1, text: {} }, dots: { text: {} }, tooltip: { container: { background: "white", color: "inherit", fontSize: "inherit", borderRadius: "2px", boxShadow: "0 1px 2px rgba(0, 0, 0, 0.25)", padding: "5px 9px" }, basic: { whiteSpace: "pre", display: "flex", alignItems: "center" }, chip: { marginRight: 7 }, table: {}, tableCell: { padding: "3px 5px" }, tableCellValue: { fontWeight: "bold" } }, crosshair: { line: { stroke: "#000000", strokeWidth: 1, strokeOpacity: 0.75, strokeDasharray: "6 6" } }, annotations: { text: { fontSize: 13, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, link: { stroke: "#000000", strokeWidth: 1, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, outline: { fill: "none", stroke: "#000000", strokeWidth: 2, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, symbol: { fill: "#000000", outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 } } };
function jr() {
  return jr = Object.assign ? Object.assign.bind() : function(e4) {
    for (var r3 = 1; r3 < arguments.length; r3++) {
      var t4 = arguments[r3];
      for (var n3 in t4) Object.prototype.hasOwnProperty.call(t4, n3) && (e4[n3] = t4[n3]);
    }
    return e4;
  }, jr.apply(this, arguments);
}
function Br(e4, r3) {
  if (null == e4) return {};
  var t4, n3, i3 = {}, o3 = Object.keys(e4);
  for (n3 = 0; n3 < o3.length; n3++) t4 = o3[n3], r3.indexOf(t4) >= 0 || (i3[t4] = e4[t4]);
  return i3;
}
var Gr = ["axis.ticks.text", "axis.legend.text", "legends.title.text", "legends.text", "legends.ticks.text", "legends.title.text", "labels.text", "dots.text", "markers.text", "annotations.text"];
var Lr = function(e4, r3) {
  return jr({}, r3, e4);
};
var Ir = function(e4, r3) {
  var t4 = (0, import_merge.default)({}, e4, r3);
  return Gr.forEach((function(e5) {
    (0, import_set.default)(t4, e5, Lr((0, import_get.default)(t4, e5), t4.text));
  })), t4;
};
var Yr = (0, import_react15.createContext)();
var Ar = function(e4) {
  var t4 = e4.children, n3 = e4.animate, i3 = void 0 === n3 || n3, o3 = e4.config, l3 = void 0 === o3 ? "default" : o3, a2 = (0, import_react15.useMemo)((function() {
    var e5 = (0, import_isString.default)(l3) ? config[l3] : l3;
    return { animate: i3, config: e5 };
  }), [i3, l3]);
  return (0, import_jsx_runtime.jsx)(Yr.Provider, { value: a2, children: t4 });
};
var Er = { animate: import_prop_types.default.bool, motionConfig: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(Object.keys(config)), import_prop_types.default.shape({ mass: import_prop_types.default.number, tension: import_prop_types.default.number, friction: import_prop_types.default.number, clamp: import_prop_types.default.bool, precision: import_prop_types.default.number, velocity: import_prop_types.default.number, duration: import_prop_types.default.number, easing: import_prop_types.default.func })]) };
Ar.propTypes = { children: import_prop_types.default.node.isRequired, animate: Er.animate, config: Er.motionConfig };
var Ur = function() {
  return (0, import_react15.useContext)(Yr);
};
var Fr = function(e4) {
  var t4 = Ur(), o3 = t4.animate, l3 = t4.config, a2 = (function(e5) {
    var r3 = (0, import_react15.useRef)();
    return (0, import_react15.useEffect)((function() {
      r3.current = e5;
    }), [e5]), r3.current;
  })(e4), d3 = (0, import_react15.useMemo)((function() {
    return string_default(a2, e4);
  }), [a2, e4]), s3 = useSpring({ from: { value: 0 }, to: { value: 1 }, reset: true, config: l3, immediate: !o3 }).value;
  return to2(s3, d3);
};
var Xr = { nivo: ["#d76445", "#f47560", "#e8c1a0", "#97e3d5", "#61cdbb", "#00b0a7"], BrBG: (0, import_last.default)(scheme), PRGn: (0, import_last.default)(scheme2), PiYG: (0, import_last.default)(scheme3), PuOr: (0, import_last.default)(scheme4), RdBu: (0, import_last.default)(scheme5), RdGy: (0, import_last.default)(scheme6), RdYlBu: (0, import_last.default)(scheme7), RdYlGn: (0, import_last.default)(scheme8), spectral: (0, import_last.default)(scheme9), blues: (0, import_last.default)(scheme22), greens: (0, import_last.default)(scheme23), greys: (0, import_last.default)(scheme24), oranges: (0, import_last.default)(scheme27), purples: (0, import_last.default)(scheme25), reds: (0, import_last.default)(scheme26), BuGn: (0, import_last.default)(scheme10), BuPu: (0, import_last.default)(scheme11), GnBu: (0, import_last.default)(scheme12), OrRd: (0, import_last.default)(scheme13), PuBuGn: (0, import_last.default)(scheme14), PuBu: (0, import_last.default)(scheme15), PuRd: (0, import_last.default)(scheme16), RdPu: (0, import_last.default)(scheme17), YlGnBu: (0, import_last.default)(scheme18), YlGn: (0, import_last.default)(scheme19), YlOrBr: (0, import_last.default)(scheme20), YlOrRd: (0, import_last.default)(scheme21) };
var Hr = Object.keys(Xr);
var Nr = { nivo: ["#e8c1a0", "#f47560", "#f1e15b", "#e8a838", "#61cdbb", "#97e3d5"], category10: category10_default, accent: Accent_default, dark2: Dark2_default, paired: Paired_default, pastel1: Pastel1_default, pastel2: Pastel2_default, set1: Set1_default, set2: Set2_default, set3: Set3_default, brown_blueGreen: (0, import_last.default)(scheme), purpleRed_green: (0, import_last.default)(scheme2), pink_yellowGreen: (0, import_last.default)(scheme3), purple_orange: (0, import_last.default)(scheme4), red_blue: (0, import_last.default)(scheme5), red_grey: (0, import_last.default)(scheme6), red_yellow_blue: (0, import_last.default)(scheme7), red_yellow_green: (0, import_last.default)(scheme8), spectral: (0, import_last.default)(scheme9), blues: (0, import_last.default)(scheme22), greens: (0, import_last.default)(scheme23), greys: (0, import_last.default)(scheme24), oranges: (0, import_last.default)(scheme27), purples: (0, import_last.default)(scheme25), reds: (0, import_last.default)(scheme26), blue_green: (0, import_last.default)(scheme10), blue_purple: (0, import_last.default)(scheme11), green_blue: (0, import_last.default)(scheme12), orange_red: (0, import_last.default)(scheme13), purple_blue_green: (0, import_last.default)(scheme14), purple_blue: (0, import_last.default)(scheme15), purple_red: (0, import_last.default)(scheme16), red_purple: (0, import_last.default)(scheme17), yellow_green_blue: (0, import_last.default)(scheme18), yellow_green: (0, import_last.default)(scheme19), yellow_orange_brown: (0, import_last.default)(scheme20), yellow_orange_red: (0, import_last.default)(scheme21) };
var et = import_prop_types.default.oneOfType([import_prop_types.default.oneOf(Hr), import_prop_types.default.func, import_prop_types.default.arrayOf(import_prop_types.default.string)]);
var rt = { basis: basis_default, basisClosed: basisClosed_default, basisOpen: basisOpen_default, bundle: bundle_default, cardinal: cardinal_default, cardinalClosed: cardinalClosed_default, cardinalOpen: cardinalOpen_default, catmullRom: catmullRom_default, catmullRomClosed: catmullRomClosed_default, catmullRomOpen: catmullRomOpen_default, linear: linear_default, linearClosed: linearClosed_default, monotoneX, monotoneY, natural: natural_default, step: step_default, stepAfter, stepBefore };
var tt = Object.keys(rt);
var nt = tt.filter((function(e4) {
  return e4.endsWith("Closed");
}));
var it = (0, import_without.default)(tt, "bundle", "basisClosed", "basisOpen", "cardinalClosed", "cardinalOpen", "catmullRomClosed", "catmullRomOpen", "linearClosed");
var ot = (0, import_without.default)(tt, "bundle", "basisClosed", "basisOpen", "cardinalClosed", "cardinalOpen", "catmullRomClosed", "catmullRomOpen", "linearClosed");
var lt = function(e4) {
  if (!rt[e4]) throw new TypeError("'" + e4 + "', is not a valid curve interpolator identifier.");
  return rt[e4];
};
var at = { ascending: ascending_default, descending: descending_default, insideOut: insideOut_default, none: none_default2, reverse: reverse_default };
var dt = Object.keys(at);
var ut = { expand: expand_default, diverging: diverging_default, none: none_default, silhouette: silhouette_default, wiggle: wiggle_default };
var ct = Object.keys(ut);
var pt = import_prop_types.default.shape({ top: import_prop_types.default.number, right: import_prop_types.default.number, bottom: import_prop_types.default.number, left: import_prop_types.default.number }).isRequired;
var ht = ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
var gt = import_prop_types.default.oneOf(ht);
var bt = function(e4) {
  return (0, import_react15.useMemo)((function() {
    return lt(e4);
  }), [e4]);
};
var vt = ordinal(Set3_default);
var _t = { top: 0, right: 0, bottom: 0, left: 0 };
var wt = function(e4, t4, n3) {
  return void 0 === n3 && (n3 = {}), (0, import_react15.useMemo)((function() {
    var r3 = jr({}, _t, n3);
    return { margin: r3, innerWidth: e4 - r3.left - r3.right, innerHeight: t4 - r3.top - r3.bottom, outerWidth: e4, outerHeight: t4 };
  }), [e4, t4, n3.top, n3.right, n3.bottom, n3.left]);
};
var kt = function() {
  var e4 = (0, import_react15.useRef)(null), r3 = (0, import_react15.useState)({ left: 0, top: 0, width: 0, height: 0 }), t4 = r3[0], l3 = r3[1], a2 = (0, import_react15.useState)((function() {
    return "undefined" == typeof ResizeObserver ? null : new ResizeObserver((function(e5) {
      var r4 = e5[0];
      return l3(r4.contentRect);
    }));
  }))[0];
  return (0, import_react15.useEffect)((function() {
    return e4.current && null !== a2 && a2.observe(e4.current), function() {
      null !== a2 && a2.disconnect();
    };
  }), []), [e4, t4];
};
var Rt = function(e4) {
  return (0, import_react15.useMemo)((function() {
    return Ir(Pr, e4);
  }), [e4]);
};
var xt = function(e4) {
  return "function" == typeof e4 ? e4 : "string" == typeof e4 ? 0 === e4.indexOf("time:") ? timeFormat(e4.slice("5")) : format(e4) : function(e5) {
    return "" + e5;
  };
};
var Ot = function(e4) {
  return (0, import_react15.useMemo)((function() {
    return xt(e4);
  }), [e4]);
};
var qt = (0, import_react15.createContext)();
var Ct = {};
var Wt = function(e4) {
  var r3 = e4.theme, t4 = void 0 === r3 ? Ct : r3, n3 = e4.children, i3 = Rt(t4);
  return (0, import_jsx_runtime.jsx)(qt.Provider, { value: i3, children: n3 });
};
Wt.propTypes = { children: import_prop_types.default.node.isRequired, theme: import_prop_types.default.object };
var zt = function() {
  return (0, import_react15.useContext)(qt);
};
var Tt = ["outlineWidth", "outlineColor", "outlineOpacity"];
var Mt = function(e4) {
  return e4.outlineWidth, e4.outlineColor, e4.outlineOpacity, Br(e4, Tt);
};
var Pt = function(e4) {
  var r3 = e4.children, t4 = e4.condition, n3 = e4.wrapper;
  return t4 ? (0, import_react15.cloneElement)(n3, {}, r3) : r3;
};
Pt.propTypes = { children: import_prop_types.default.node.isRequired, condition: import_prop_types.default.bool.isRequired, wrapper: import_prop_types.default.element.isRequired };
var jt = { position: "relative" };
var St = function(e4) {
  var r3 = e4.children, t4 = e4.theme, i3 = e4.renderWrapper, o3 = void 0 === i3 || i3, l3 = e4.isInteractive, a2 = void 0 === l3 || l3, d3 = e4.animate, s3 = e4.motionConfig, u3 = (0, import_react15.useRef)(null);
  return (0, import_jsx_runtime.jsx)(Wt, { theme: t4, children: (0, import_jsx_runtime.jsx)(Ar, { animate: d3, config: s3, children: (0, import_jsx_runtime.jsx)(M, { container: u3, children: (0, import_jsx_runtime.jsxs)(Pt, { condition: o3, wrapper: (0, import_jsx_runtime.jsx)("div", { style: jt, ref: u3 }), children: [r3, a2 && (0, import_jsx_runtime.jsx)(F, {})] }) }) }) });
};
St.propTypes = { children: import_prop_types.default.element.isRequired, isInteractive: import_prop_types.default.bool, renderWrapper: import_prop_types.default.bool, theme: import_prop_types.default.object, animate: import_prop_types.default.bool, motionConfig: import_prop_types.default.string };
var Bt = function() {
};
var Gt = { position: "relative" };
var Lt = function(e4) {
  var t4 = e4.children, i3 = e4.theme, o3 = e4.isInteractive, l3 = void 0 === o3 || o3, d3 = e4.renderWrapper, s3 = void 0 === d3 || d3, u3 = e4.animate, c9 = e4.motionConfig, f3 = (0, import_react15.useRef)(null), m4 = V(f3), y4 = m4.actions, v4 = m4.state, _ = (0, import_react15.useCallback)((function(e5, r3) {
    return y4.showTooltipFromEvent(e5, r3);
  }), [y4.showTooltipFromEvent]), w3 = (0, import_react15.useMemo)((function() {
    return { showTooltip: l3 ? _ : Bt, hideTooltip: l3 ? y4.hideTooltip : Bt };
  }), [y4.hideTooltip, l3, _]);
  return (0, import_jsx_runtime.jsx)(Wt, { theme: i3, children: (0, import_jsx_runtime.jsx)(Ar, { animate: u3, config: c9, children: (0, import_jsx_runtime.jsx)(j.Provider, { value: y4, children: (0, import_jsx_runtime.jsx)(O.Provider, { value: v4, children: (0, import_jsx_runtime.jsxs)(Pt, { condition: s3, wrapper: (0, import_jsx_runtime.jsx)("div", { style: Gt, ref: f3 }), children: [t4(w3), l3 && (0, import_jsx_runtime.jsx)(F, {})] }) }) }) }) });
};
Lt.propTypes = { children: import_prop_types.default.func.isRequired, isInteractive: import_prop_types.default.bool, renderWrapper: import_prop_types.default.bool, theme: import_prop_types.default.object.isRequired, animate: import_prop_types.default.bool.isRequired, motionConfig: import_prop_types.default.string };
var It = function(e4) {
  var r3 = e4.children, t4 = kt(), n3 = t4[0], i3 = t4[1], o3 = i3.width > 0 && i3.height > 0;
  return (0, import_jsx_runtime.jsx)("div", { ref: n3, style: { width: "100%", height: "100%" }, children: o3 && r3({ width: i3.width, height: i3.height }) });
};
It.propTypes = { children: import_prop_types.default.func.isRequired };
var Yt = ["id", "colors"];
var Dt = function(e4) {
  var r3 = e4.id, t4 = e4.colors, n3 = Br(e4, Yt);
  return (0, import_jsx_runtime.jsx)("linearGradient", jr({ id: r3, x1: 0, x2: 0, y1: 0, y2: 1 }, n3, { children: t4.map((function(e5) {
    var r4 = e5.offset, t5 = e5.color, n4 = e5.opacity;
    return (0, import_jsx_runtime.jsx)("stop", { offset: r4 + "%", stopColor: t5, stopOpacity: void 0 !== n4 ? n4 : 1 }, r4);
  })) }));
};
Dt.propTypes = { id: import_prop_types.default.string.isRequired, colors: import_prop_types.default.arrayOf(import_prop_types.default.shape({ offset: import_prop_types.default.number.isRequired, color: import_prop_types.default.string.isRequired, opacity: import_prop_types.default.number })).isRequired, gradientTransform: import_prop_types.default.string };
var Et = { linearGradient: Dt };
var Ut = { color: "#000000", background: "#ffffff", size: 4, padding: 4, stagger: false };
var Ft = (0, import_react15.memo)((function(e4) {
  var r3 = e4.id, t4 = e4.background, n3 = void 0 === t4 ? Ut.background : t4, i3 = e4.color, o3 = void 0 === i3 ? Ut.color : i3, l3 = e4.size, a2 = void 0 === l3 ? Ut.size : l3, d3 = e4.padding, s3 = void 0 === d3 ? Ut.padding : d3, u3 = e4.stagger, c9 = void 0 === u3 ? Ut.stagger : u3, f3 = a2 + s3, p3 = a2 / 2, h2 = s3 / 2;
  return true === c9 && (f3 = 2 * a2 + 2 * s3), (0, import_jsx_runtime.jsxs)("pattern", { id: r3, width: f3, height: f3, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("rect", { width: f3, height: f3, fill: n3 }), (0, import_jsx_runtime.jsx)("circle", { cx: h2 + p3, cy: h2 + p3, r: p3, fill: o3 }), c9 && (0, import_jsx_runtime.jsx)("circle", { cx: 1.5 * s3 + a2 + p3, cy: 1.5 * s3 + a2 + p3, r: p3, fill: o3 })] });
}));
Ft.displayName = "PatternDots", Ft.propTypes = { id: import_prop_types.default.string.isRequired, color: import_prop_types.default.string.isRequired, background: import_prop_types.default.string.isRequired, size: import_prop_types.default.number.isRequired, padding: import_prop_types.default.number.isRequired, stagger: import_prop_types.default.bool.isRequired };
var Ht = 2 * Math.PI;
var Kt = function(e4) {
  return e4 * Math.PI / 180;
};
var Nt = function(e4) {
  return 180 * e4 / Math.PI;
};
var Jt = function(e4, r3) {
  return { x: Math.cos(e4) * r3, y: Math.sin(e4) * r3 };
};
var Qt = function(e4) {
  var r3 = e4 % 360;
  return r3 < 0 && (r3 += 360), r3;
};
var rn = { svg: { align: { left: "start", center: "middle", right: "end", start: "start", middle: "middle", end: "end" }, baseline: { top: "text-before-edge", center: "central", bottom: "alphabetic" } }, canvas: { align: { left: "left", center: "center", right: "right", start: "left", middle: "center", end: "right" }, baseline: { top: "top", center: "middle", bottom: "bottom" } } };
var nn = { spacing: 5, rotation: 0, background: "#000000", color: "#ffffff", lineWidth: 2 };
var on = (0, import_react15.memo)((function(e4) {
  var r3 = e4.id, t4 = e4.spacing, n3 = void 0 === t4 ? nn.spacing : t4, i3 = e4.rotation, o3 = void 0 === i3 ? nn.rotation : i3, l3 = e4.background, a2 = void 0 === l3 ? nn.background : l3, d3 = e4.color, s3 = void 0 === d3 ? nn.color : d3, u3 = e4.lineWidth, c9 = void 0 === u3 ? nn.lineWidth : u3, f3 = Math.round(o3) % 360, p3 = Math.abs(n3);
  f3 > 180 ? f3 -= 360 : f3 > 90 ? f3 -= 180 : f3 < -180 ? f3 += 360 : f3 < -90 && (f3 += 180);
  var h2, g3 = p3, b3 = p3;
  return 0 === f3 ? h2 = "\n                M 0 0 L " + g3 + " 0\n                M 0 " + b3 + " L " + g3 + " " + b3 + "\n            " : 90 === f3 ? h2 = "\n                M 0 0 L 0 " + b3 + "\n                M " + g3 + " 0 L " + g3 + " " + b3 + "\n            " : (g3 = Math.abs(p3 / Math.sin(Kt(f3))), b3 = p3 / Math.sin(Kt(90 - f3)), h2 = f3 > 0 ? "\n                    M 0 " + -b3 + " L " + 2 * g3 + " " + b3 + "\n                    M " + -g3 + " " + -b3 + " L " + g3 + " " + b3 + "\n                    M " + -g3 + " 0 L " + g3 + " " + 2 * b3 + "\n                " : "\n                    M " + -g3 + " " + b3 + " L " + g3 + " " + -b3 + "\n                    M " + -g3 + " " + 2 * b3 + " L " + 2 * g3 + " " + -b3 + "\n                    M 0 " + 2 * b3 + " L " + 2 * g3 + " 0\n                "), (0, import_jsx_runtime.jsxs)("pattern", { id: r3, width: g3, height: b3, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("rect", { width: g3, height: b3, fill: a2, stroke: "rgba(255, 0, 0, 0.1)", strokeWidth: 0 }), (0, import_jsx_runtime.jsx)("path", { d: h2, strokeWidth: c9, stroke: s3, strokeLinecap: "square" })] });
}));
on.displayName = "PatternLines", on.propTypes = { id: import_prop_types.default.string.isRequired, spacing: import_prop_types.default.number.isRequired, rotation: import_prop_types.default.number.isRequired, background: import_prop_types.default.string.isRequired, color: import_prop_types.default.string.isRequired, lineWidth: import_prop_types.default.number.isRequired };
var an = { color: "#000000", background: "#ffffff", size: 4, padding: 4, stagger: false };
var dn = (0, import_react15.memo)((function(e4) {
  var r3 = e4.id, t4 = e4.color, n3 = void 0 === t4 ? an.color : t4, i3 = e4.background, o3 = void 0 === i3 ? an.background : i3, l3 = e4.size, a2 = void 0 === l3 ? an.size : l3, d3 = e4.padding, s3 = void 0 === d3 ? an.padding : d3, u3 = e4.stagger, c9 = void 0 === u3 ? an.stagger : u3, f3 = a2 + s3, p3 = s3 / 2;
  return true === c9 && (f3 = 2 * a2 + 2 * s3), (0, import_jsx_runtime.jsxs)("pattern", { id: r3, width: f3, height: f3, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("rect", { width: f3, height: f3, fill: o3 }), (0, import_jsx_runtime.jsx)("rect", { x: p3, y: p3, width: a2, height: a2, fill: n3 }), c9 && (0, import_jsx_runtime.jsx)("rect", { x: 1.5 * s3 + a2, y: 1.5 * s3 + a2, width: a2, height: a2, fill: n3 })] });
}));
dn.displayName = "PatternSquares", dn.propTypes = { id: import_prop_types.default.string.isRequired, color: import_prop_types.default.string.isRequired, background: import_prop_types.default.string.isRequired, size: import_prop_types.default.number.isRequired, padding: import_prop_types.default.number.isRequired, stagger: import_prop_types.default.bool.isRequired };
var un = { patternDots: Ft, patternLines: on, patternSquares: dn };
var cn = ["type"];
var fn = jr({}, Et, un);
var pn = function(e4) {
  var r3 = e4.defs;
  return !r3 || r3.length < 1 ? null : (0, import_jsx_runtime.jsx)("defs", { "aria-hidden": true, children: r3.map((function(e5) {
    var r4 = e5.type, t4 = Br(e5, cn);
    return fn[r4] ? (0, import_react15.createElement)(fn[r4], jr({ key: t4.id }, t4)) : null;
  })) });
};
pn.propTypes = { defs: import_prop_types.default.arrayOf(import_prop_types.default.shape({ type: import_prop_types.default.oneOf(Object.keys(fn)).isRequired, id: import_prop_types.default.string.isRequired })) };
var hn = (0, import_react15.memo)(pn);
var gn = function(e4) {
  var r3 = e4.width, t4 = e4.height, n3 = e4.margin, i3 = e4.defs, o3 = e4.children, l3 = e4.role, a2 = e4.ariaLabel, d3 = e4.ariaLabelledBy, s3 = e4.ariaDescribedBy, u3 = e4.isFocusable, c9 = zt();
  return (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: r3, height: t4, role: l3, "aria-label": a2, "aria-labelledby": d3, "aria-describedby": s3, focusable: u3, tabIndex: u3 ? 0 : void 0, children: [(0, import_jsx_runtime.jsx)(hn, { defs: i3 }), (0, import_jsx_runtime.jsx)("rect", { width: r3, height: t4, fill: c9.background }), (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + n3.left + "," + n3.top + ")", children: o3 })] });
};
gn.propTypes = { width: import_prop_types.default.number.isRequired, height: import_prop_types.default.number.isRequired, margin: import_prop_types.default.shape({ top: import_prop_types.default.number.isRequired, left: import_prop_types.default.number.isRequired }).isRequired, defs: import_prop_types.default.array, children: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.node), import_prop_types.default.node]).isRequired, role: import_prop_types.default.string, isFocusable: import_prop_types.default.bool, ariaLabel: import_prop_types.default.string, ariaLabelledBy: import_prop_types.default.string, ariaDescribedBy: import_prop_types.default.string };
var bn = function(e4) {
  var r3 = e4.size, t4 = e4.color, n3 = e4.borderWidth, i3 = e4.borderColor;
  return (0, import_jsx_runtime.jsx)("circle", { r: r3 / 2, fill: t4, stroke: i3, strokeWidth: n3, style: { pointerEvents: "none" } });
};
bn.propTypes = { size: import_prop_types.default.number.isRequired, color: import_prop_types.default.string.isRequired, borderWidth: import_prop_types.default.number.isRequired, borderColor: import_prop_types.default.string.isRequired };
var mn = (0, import_react15.memo)(bn);
var yn = function(e4) {
  var r3 = e4.x, t4 = e4.y, n3 = e4.symbol, i3 = void 0 === n3 ? mn : n3, o3 = e4.size, l3 = e4.datum, a2 = e4.color, d3 = e4.borderWidth, u3 = e4.borderColor, c9 = e4.label, f3 = e4.labelTextAnchor, p3 = void 0 === f3 ? "middle" : f3, h2 = e4.labelYOffset, g3 = void 0 === h2 ? -12 : h2, b3 = zt(), m4 = Ur(), y4 = m4.animate, v4 = m4.config, _ = useSpring({ transform: "translate(" + r3 + ", " + t4 + ")", config: v4, immediate: !y4 });
  return (0, import_jsx_runtime.jsxs)(animated.g, { transform: _.transform, style: { pointerEvents: "none" }, children: [(0, import_react15.createElement)(i3, { size: o3, color: a2, datum: l3, borderWidth: d3, borderColor: u3 }), c9 && (0, import_jsx_runtime.jsx)("text", { textAnchor: p3, y: g3, style: Mt(b3.dots.text), children: c9 })] });
};
yn.propTypes = { x: import_prop_types.default.number.isRequired, y: import_prop_types.default.number.isRequired, datum: import_prop_types.default.object.isRequired, size: import_prop_types.default.number.isRequired, color: import_prop_types.default.string.isRequired, borderWidth: import_prop_types.default.number.isRequired, borderColor: import_prop_types.default.string.isRequired, symbol: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]), label: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number]), labelTextAnchor: import_prop_types.default.oneOf(["start", "middle", "end"]), labelYOffset: import_prop_types.default.number };
var vn = (0, import_react15.memo)(yn);
var _n = function(e4) {
  var r3 = e4.width, t4 = e4.height, n3 = e4.axis, i3 = e4.scale, o3 = e4.value, l3 = e4.lineStyle, a2 = e4.textStyle, d3 = e4.legend, s3 = e4.legendPosition, u3 = void 0 === s3 ? "top-right" : s3, c9 = e4.legendOffsetX, f3 = void 0 === c9 ? 14 : c9, p3 = e4.legendOffsetY, h2 = void 0 === p3 ? 14 : p3, g3 = e4.legendOrientation, b3 = void 0 === g3 ? "horizontal" : g3, m4 = zt(), y4 = 0, v4 = 0, _ = 0, w3 = 0;
  "y" === n3 ? (_ = i3(o3), v4 = r3) : (y4 = i3(o3), w3 = t4);
  var k3 = null;
  if (d3) {
    var R = (function(e5) {
      var r4 = e5.axis, t5 = e5.width, n4 = e5.height, i4 = e5.position, o4 = e5.offsetX, l4 = e5.offsetY, a3 = e5.orientation, d4 = 0, s4 = 0, u4 = "vertical" === a3 ? -90 : 0, c10 = "start";
      if ("x" === r4) switch (i4) {
        case "top-left":
          d4 = -o4, s4 = l4, c10 = "end";
          break;
        case "top":
          s4 = -l4, c10 = "horizontal" === a3 ? "middle" : "start";
          break;
        case "top-right":
          d4 = o4, s4 = l4, c10 = "horizontal" === a3 ? "start" : "end";
          break;
        case "right":
          d4 = o4, s4 = n4 / 2, c10 = "horizontal" === a3 ? "start" : "middle";
          break;
        case "bottom-right":
          d4 = o4, s4 = n4 - l4, c10 = "start";
          break;
        case "bottom":
          s4 = n4 + l4, c10 = "horizontal" === a3 ? "middle" : "end";
          break;
        case "bottom-left":
          s4 = n4 - l4, d4 = -o4, c10 = "horizontal" === a3 ? "end" : "start";
          break;
        case "left":
          d4 = -o4, s4 = n4 / 2, c10 = "horizontal" === a3 ? "end" : "middle";
      }
      else switch (i4) {
        case "top-left":
          d4 = o4, s4 = -l4, c10 = "start";
          break;
        case "top":
          d4 = t5 / 2, s4 = -l4, c10 = "horizontal" === a3 ? "middle" : "start";
          break;
        case "top-right":
          d4 = t5 - o4, s4 = -l4, c10 = "horizontal" === a3 ? "end" : "start";
          break;
        case "right":
          d4 = t5 + o4, c10 = "horizontal" === a3 ? "start" : "middle";
          break;
        case "bottom-right":
          d4 = t5 - o4, s4 = l4, c10 = "end";
          break;
        case "bottom":
          d4 = t5 / 2, s4 = l4, c10 = "horizontal" === a3 ? "middle" : "end";
          break;
        case "bottom-left":
          d4 = o4, s4 = l4, c10 = "horizontal" === a3 ? "start" : "end";
          break;
        case "left":
          d4 = -o4, c10 = "horizontal" === a3 ? "end" : "middle";
      }
      return { x: d4, y: s4, rotation: u4, textAnchor: c10 };
    })({ axis: n3, width: r3, height: t4, position: u3, offsetX: f3, offsetY: h2, orientation: b3 });
    k3 = (0, import_jsx_runtime.jsx)("text", { transform: "translate(" + R.x + ", " + R.y + ") rotate(" + R.rotation + ")", textAnchor: R.textAnchor, dominantBaseline: "central", style: a2, children: d3 });
  }
  return (0, import_jsx_runtime.jsxs)("g", { transform: "translate(" + y4 + ", " + _ + ")", children: [(0, import_jsx_runtime.jsx)("line", { x1: 0, x2: v4, y1: 0, y2: w3, stroke: m4.markers.lineColor, strokeWidth: m4.markers.lineStrokeWidth, style: l3 }), k3] });
};
_n.propTypes = { width: import_prop_types.default.number.isRequired, height: import_prop_types.default.number.isRequired, axis: import_prop_types.default.oneOf(["x", "y"]).isRequired, scale: import_prop_types.default.func.isRequired, value: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.instanceOf(Date)]).isRequired, lineStyle: import_prop_types.default.object, textStyle: import_prop_types.default.object, legend: import_prop_types.default.string, legendPosition: import_prop_types.default.oneOf(["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"]), legendOffsetX: import_prop_types.default.number.isRequired, legendOffsetY: import_prop_types.default.number.isRequired, legendOrientation: import_prop_types.default.oneOf(["horizontal", "vertical"]).isRequired };
var wn = (0, import_react15.memo)(_n);
var kn = function(e4) {
  var r3 = e4.markers, t4 = e4.width, n3 = e4.height, i3 = e4.xScale, o3 = e4.yScale;
  return r3 && 0 !== r3.length ? r3.map((function(e5, r4) {
    return (0, import_jsx_runtime.jsx)(wn, jr({}, e5, { width: t4, height: n3, scale: "y" === e5.axis ? o3 : i3 }), r4);
  })) : null;
};
kn.propTypes = { width: import_prop_types.default.number.isRequired, height: import_prop_types.default.number.isRequired, xScale: import_prop_types.default.func.isRequired, yScale: import_prop_types.default.func.isRequired, markers: import_prop_types.default.arrayOf(import_prop_types.default.shape({ axis: import_prop_types.default.oneOf(["x", "y"]).isRequired, value: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.instanceOf(Date)]).isRequired, lineStyle: import_prop_types.default.object, textStyle: import_prop_types.default.object })) };
var Rn = (0, import_react15.memo)(kn);
var Cn = function(e4) {
  return (0, import_isFunction.default)(e4) ? e4 : function(r3) {
    return (0, import_get.default)(r3, e4);
  };
};
var Wn = function(e4) {
  return (0, import_react15.useMemo)((function() {
    return Cn(e4);
  }), [e4]);
};
var jn = function(e4, r3, t4, n3, i3, o3) {
  return e4 <= i3 && i3 <= e4 + t4 && r3 <= o3 && o3 <= r3 + n3;
};
var Sn = function(e4, r3) {
  var t4, n3 = "touches" in r3 ? r3.touches[0] : r3, i3 = n3.clientX, o3 = n3.clientY, l3 = e4.getBoundingClientRect(), a2 = (t4 = void 0 !== e4.getBBox ? e4.getBBox() : { width: e4.offsetWidth || 0, height: e4.offsetHeight || 0 }).width === l3.width ? 1 : t4.width / l3.width;
  return [(i3 - l3.left) * a2, (o3 - l3.top) * a2];
};
var Bn = Object.keys(Et);
var Gn = Object.keys(un);
var Ln = function(e4, r3, t4) {
  if ("*" === e4) return true;
  if ((0, import_isFunction.default)(e4)) return e4(r3);
  if ((0, import_isPlainObject.default)(e4)) {
    var n3 = t4 ? (0, import_get.default)(r3, t4) : r3;
    return (0, import_isEqual.default)((0, import_pick.default)(n3, Object.keys(e4)), e4);
  }
  return false;
};
var In = function(e4, r3, t4, n3) {
  var i3 = void 0 === n3 ? {} : n3, o3 = i3.dataKey, l3 = i3.colorKey, a2 = void 0 === l3 ? "color" : l3, d3 = i3.targetKey, s3 = void 0 === d3 ? "fill" : d3, u3 = [], c9 = {};
  return e4.length && r3.length && (u3 = [].concat(e4), r3.forEach((function(r4) {
    for (var n4 = function() {
      var n5 = t4[i4], l4 = n5.id, d4 = n5.match;
      if (Ln(d4, r4, o3)) {
        var f3 = e4.find((function(e5) {
          return e5.id === l4;
        }));
        if (f3) {
          if (Gn.includes(f3.type)) if ("inherit" === f3.background || "inherit" === f3.color) {
            var p3 = (0, import_get.default)(r4, a2), h2 = f3.background, g3 = f3.color, b3 = l4;
            "inherit" === f3.background && (b3 = b3 + ".bg." + p3, h2 = p3), "inherit" === f3.color && (b3 = b3 + ".fg." + p3, g3 = p3), (0, import_set.default)(r4, s3, "url(#" + b3 + ")"), c9[b3] || (u3.push(jr({}, f3, { id: b3, background: h2, color: g3 })), c9[b3] = 1);
          } else (0, import_set.default)(r4, s3, "url(#" + l4 + ")");
          else if (Bn.includes(f3.type)) {
            if (f3.colors.map((function(e5) {
              return e5.color;
            })).includes("inherit")) {
              var m4 = (0, import_get.default)(r4, a2), _ = l4, w3 = jr({}, f3, { colors: f3.colors.map((function(e5, r5) {
                return "inherit" !== e5.color ? e5 : (_ = _ + "." + r5 + "." + m4, jr({}, e5, { color: "inherit" === e5.color ? m4 : e5.color }));
              })) });
              w3.id = _, (0, import_set.default)(r4, s3, "url(#" + _ + ")"), c9[_] || (u3.push(w3), c9[_] = 1);
            } else (0, import_set.default)(r4, s3, "url(#" + l4 + ")");
          }
        }
        return "break";
      }
    }, i4 = 0; i4 < t4.length; i4++) {
      if ("break" === n4()) break;
    }
  }))), u3;
};

// node_modules/@nivo/tooltip/dist/nivo-tooltip.es.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function v2() {
  return v2 = Object.assign ? Object.assign.bind() : function(t4) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var o3 = arguments[i3];
      for (var n3 in o3) Object.prototype.hasOwnProperty.call(o3, n3) && (t4[n3] = o3[n3]);
    }
    return t4;
  }, v2.apply(this, arguments);
}
var x = { pointerEvents: "none", position: "absolute", zIndex: 10, top: 0, left: 0 };
var m2 = function(t4, i3) {
  return "translate(" + t4 + "px, " + i3 + "px)";
};
var b = (0, import_react16.memo)((function(t4) {
  var o3, n3 = t4.position, r3 = t4.anchor, e4 = t4.children, l3 = zt(), d3 = Ur(), y4 = d3.animate, f3 = d3.config, b3 = kt(), g3 = b3[0], w3 = b3[1], T2 = (0, import_react16.useRef)(false), C4 = void 0, E3 = false, P2 = w3.width > 0 && w3.height > 0, j2 = Math.round(n3[0]), N2 = Math.round(n3[1]);
  P2 && ("top" === r3 ? (j2 -= w3.width / 2, N2 -= w3.height + 14) : "right" === r3 ? (j2 += 14, N2 -= w3.height / 2) : "bottom" === r3 ? (j2 -= w3.width / 2, N2 += 14) : "left" === r3 ? (j2 -= w3.width + 14, N2 -= w3.height / 2) : "center" === r3 && (j2 -= w3.width / 2, N2 -= w3.height / 2), C4 = { transform: m2(j2, N2) }, T2.current || (E3 = true), T2.current = [j2, N2]);
  var O4 = useSpring({ to: C4, config: f3, immediate: !y4 || E3 }), V2 = v2({}, x, l3.tooltip.wrapper, { transform: null != (o3 = O4.transform) ? o3 : m2(j2, N2), opacity: O4.transform ? 1 : 0 });
  return (0, import_jsx_runtime2.jsx)(animated.div, { ref: g3, style: V2, children: e4 });
}));
b.displayName = "TooltipWrapper";
var g = (0, import_react16.memo)((function(t4) {
  var i3 = t4.size, o3 = void 0 === i3 ? 12 : i3, n3 = t4.color, r3 = t4.style;
  return (0, import_jsx_runtime2.jsx)("span", { style: v2({ display: "block", width: o3, height: o3, background: n3 }, void 0 === r3 ? {} : r3) });
}));
var w = (0, import_react16.memo)((function(t4) {
  var i3, o3 = t4.id, n3 = t4.value, r3 = t4.format, e4 = t4.enableChip, l3 = void 0 !== e4 && e4, a2 = t4.color, c9 = t4.renderContent, h2 = zt(), u3 = Ot(r3);
  if ("function" == typeof c9) i3 = c9();
  else {
    var f3 = n3;
    void 0 !== u3 && void 0 !== f3 && (f3 = u3(f3)), i3 = (0, import_jsx_runtime2.jsxs)("div", { style: h2.tooltip.basic, children: [l3 && (0, import_jsx_runtime2.jsx)(g, { color: a2, style: h2.tooltip.chip }), void 0 !== f3 ? (0, import_jsx_runtime2.jsxs)("span", { children: [o3, ": ", (0, import_jsx_runtime2.jsx)("strong", { children: "" + f3 })] }) : o3] });
  }
  return (0, import_jsx_runtime2.jsx)("div", { style: h2.tooltip.container, children: i3 });
}));
var T = { width: "100%", borderCollapse: "collapse" };
var C2 = (0, import_react16.memo)((function(t4) {
  var i3, o3 = t4.title, n3 = t4.rows, r3 = void 0 === n3 ? [] : n3, e4 = t4.renderContent, l3 = zt();
  return r3.length ? (i3 = "function" == typeof e4 ? e4() : (0, import_jsx_runtime2.jsxs)("div", { children: [o3 && o3, (0, import_jsx_runtime2.jsx)("table", { style: v2({}, T, l3.tooltip.table), children: (0, import_jsx_runtime2.jsx)("tbody", { children: r3.map((function(t5, i4) {
    return (0, import_jsx_runtime2.jsx)("tr", { children: t5.map((function(t6, i5) {
      return (0, import_jsx_runtime2.jsx)("td", { style: l3.tooltip.tableCell, children: t6 }, i5);
    })) }, i4);
  })) }) })] }), (0, import_jsx_runtime2.jsx)("div", { style: l3.tooltip.container, children: i3 })) : null;
}));
C2.displayName = "TableTooltip";
var E = (0, import_react16.memo)((function(t4) {
  var i3 = t4.x0, n3 = t4.x1, r3 = t4.y0, e4 = t4.y1, l3 = zt(), u3 = Ur(), d3 = u3.animate, y4 = u3.config, f3 = (0, import_react16.useMemo)((function() {
    return v2({}, l3.crosshair.line, { pointerEvents: "none" });
  }), [l3.crosshair.line]), x3 = useSpring({ x1: i3, x2: n3, y1: r3, y2: e4, config: y4, immediate: !d3 });
  return (0, import_jsx_runtime2.jsx)(animated.line, v2({}, x3, { fill: "none", style: f3 }));
}));
E.displayName = "CrosshairLine";
var P = (0, import_react16.memo)((function(t4) {
  var i3, o3, n3 = t4.width, r3 = t4.height, e4 = t4.type, l3 = t4.x, a2 = t4.y;
  return "cross" === e4 ? (i3 = { x0: l3, x1: l3, y0: 0, y1: r3 }, o3 = { x0: 0, x1: n3, y0: a2, y1: a2 }) : "top-left" === e4 ? (i3 = { x0: l3, x1: l3, y0: 0, y1: a2 }, o3 = { x0: 0, x1: l3, y0: a2, y1: a2 }) : "top" === e4 ? i3 = { x0: l3, x1: l3, y0: 0, y1: a2 } : "top-right" === e4 ? (i3 = { x0: l3, x1: l3, y0: 0, y1: a2 }, o3 = { x0: l3, x1: n3, y0: a2, y1: a2 }) : "right" === e4 ? o3 = { x0: l3, x1: n3, y0: a2, y1: a2 } : "bottom-right" === e4 ? (i3 = { x0: l3, x1: l3, y0: a2, y1: r3 }, o3 = { x0: l3, x1: n3, y0: a2, y1: a2 }) : "bottom" === e4 ? i3 = { x0: l3, x1: l3, y0: a2, y1: r3 } : "bottom-left" === e4 ? (i3 = { x0: l3, x1: l3, y0: a2, y1: r3 }, o3 = { x0: 0, x1: l3, y0: a2, y1: a2 }) : "left" === e4 ? o3 = { x0: 0, x1: l3, y0: a2, y1: a2 } : "x" === e4 ? i3 = { x0: l3, x1: l3, y0: 0, y1: r3 } : "y" === e4 && (o3 = { x0: 0, x1: n3, y0: a2, y1: a2 }), (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [i3 && (0, import_jsx_runtime2.jsx)(E, { x0: i3.x0, x1: i3.x1, y0: i3.y0, y1: i3.y1 }), o3 && (0, import_jsx_runtime2.jsx)(E, { x0: o3.x0, x1: o3.x1, y0: o3.y0, y1: o3.y1 })] });
}));
P.displayName = "Crosshair";
var j = (0, import_react16.createContext)({ showTooltipAt: function() {
}, showTooltipFromEvent: function() {
}, hideTooltip: function() {
} });
var N = { isVisible: false, position: [null, null], content: null, anchor: null };
var O = (0, import_react16.createContext)(N);
var V = function(t4) {
  var i3 = (0, import_react16.useState)(N), n3 = i3[0], l3 = i3[1], a2 = (0, import_react16.useCallback)((function(t5, i4, o3) {
    var n4 = i4[0], r3 = i4[1];
    void 0 === o3 && (o3 = "top"), l3({ isVisible: true, position: [n4, r3], anchor: o3, content: t5 });
  }), [l3]), c9 = (0, import_react16.useCallback)((function(i4, o3, n4) {
    void 0 === n4 && (n4 = "top");
    var r3 = t4.current.getBoundingClientRect(), e4 = t4.current.offsetWidth, a3 = e4 === r3.width ? 1 : e4 / r3.width, c10 = "touches" in o3 ? o3.touches[0] : o3, s4 = c10.clientX, h2 = c10.clientY, u3 = (s4 - r3.left) * a3, d3 = (h2 - r3.top) * a3;
    "left" !== n4 && "right" !== n4 || (n4 = u3 < r3.width / 2 ? "right" : "left"), l3({ isVisible: true, position: [u3, d3], anchor: n4, content: i4 });
  }), [t4, l3]), s3 = (0, import_react16.useCallback)((function() {
    l3(N);
  }), [l3]);
  return { actions: (0, import_react16.useMemo)((function() {
    return { showTooltipAt: a2, showTooltipFromEvent: c9, hideTooltip: s3 };
  }), [a2, c9, s3]), state: n3 };
};
var k = function() {
  var t4 = (0, import_react16.useContext)(j);
  if (void 0 === t4) throw new Error("useTooltip must be used within a TooltipProvider");
  return t4;
};
var z2 = function() {
  var t4 = (0, import_react16.useContext)(O);
  if (void 0 === t4) throw new Error("useTooltipState must be used within a TooltipProvider");
  return t4;
};
var A = function(t4) {
  return t4.isVisible;
};
var F = function() {
  var t4 = z2();
  return A(t4) ? (0, import_jsx_runtime2.jsx)(b, { position: t4.position, anchor: t4.anchor, children: t4.content }) : null;
};
var M = function(t4) {
  var i3 = t4.container, o3 = t4.children, n3 = V(i3), r3 = n3.actions, e4 = n3.state;
  return (0, import_jsx_runtime2.jsx)(j.Provider, { value: r3, children: (0, import_jsx_runtime2.jsx)(O.Provider, { value: e4, children: o3 }) });
};

// node_modules/@nivo/colors/dist/nivo-colors.es.js
var import_react17 = __toESM(require_react());
var import_get2 = __toESM(require_get());
var import_isPlainObject2 = __toESM(require_isPlainObject());
var import_prop_types2 = __toESM(require_prop_types());
function qe() {
  return qe = Object.assign ? Object.assign.bind() : function(e4) {
    for (var r3 = 1; r3 < arguments.length; r3++) {
      var n3 = arguments[r3];
      for (var t4 in n3) Object.prototype.hasOwnProperty.call(n3, t4) && (e4[t4] = n3[t4]);
    }
    return e4;
  }, qe.apply(this, arguments);
}
function Ce(e4, r3) {
  (null == r3 || r3 > e4.length) && (r3 = e4.length);
  for (var n3 = 0, t4 = new Array(r3); n3 < r3; n3++) t4[n3] = e4[n3];
  return t4;
}
function Ge(e4, r3) {
  var n3 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
  if (n3) return (n3 = n3.call(e4)).next.bind(n3);
  if (Array.isArray(e4) || (n3 = (function(e5, r4) {
    if (e5) {
      if ("string" == typeof e5) return Ce(e5, r4);
      var n4 = Object.prototype.toString.call(e5).slice(8, -1);
      return "Object" === n4 && e5.constructor && (n4 = e5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(e5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? Ce(e5, r4) : void 0;
    }
  })(e4)) || r3 && e4 && "number" == typeof e4.length) {
    n3 && (e4 = n3);
    var t4 = 0;
    return function() {
      return t4 >= e4.length ? { done: true } : { done: false, value: e4[t4++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var Re = { nivo: ["#e8c1a0", "#f47560", "#f1e15b", "#e8a838", "#61cdbb", "#97e3d5"], category10: category10_default, accent: Accent_default, dark2: Dark2_default, paired: Paired_default, pastel1: Pastel1_default, pastel2: Pastel2_default, set1: Set1_default, set2: Set2_default, set3: Set3_default, tableau10: Tableau10_default };
var Ve = Object.keys(Re);
var Pe = { brown_blueGreen: scheme, purpleRed_green: scheme2, pink_yellowGreen: scheme3, purple_orange: scheme4, red_blue: scheme5, red_grey: scheme6, red_yellow_blue: scheme7, red_yellow_green: scheme8, spectral: scheme9 };
var Te = Object.keys(Pe);
var Ue = { brown_blueGreen: BrBG_default, purpleRed_green: PRGn_default, pink_yellowGreen: PiYG_default, purple_orange: PuOr_default, red_blue: RdBu_default, red_grey: RdGy_default, red_yellow_blue: RdYlBu_default, red_yellow_green: RdYlGn_default, spectral: Spectral_default };
var De = { blues: scheme22, greens: scheme23, greys: scheme24, oranges: scheme27, purples: scheme25, reds: scheme26, blue_green: scheme10, blue_purple: scheme11, green_blue: scheme12, orange_red: scheme13, purple_blue_green: scheme14, purple_blue: scheme15, purple_red: scheme16, red_purple: scheme17, yellow_green_blue: scheme18, yellow_green: scheme19, yellow_orange_brown: scheme20, yellow_orange_red: scheme21 };
var Me = Object.keys(De);
var $e = { blues: Blues_default, greens: Greens_default, greys: Greys_default, oranges: Oranges_default, purples: Purples_default, reds: Reds_default, turbo: turbo_default, viridis: viridis_default, inferno, magma, plasma, cividis: cividis_default, warm, cool, cubehelixDefault: cubehelix_default, blue_green: BuGn_default, blue_purple: BuPu_default, green_blue: GnBu_default, orange_red: OrRd_default, purple_blue_green: PuBuGn_default, purple_blue: PuBu_default, purple_red: PuRd_default, red_purple: RdPu_default, yellow_green_blue: YlGnBu_default, yellow_green: YlGn_default, yellow_orange_brown: YlOrBr_default, yellow_orange_red: YlOrRd_default };
var Be = qe({}, Re, Pe, De);
var Fe = Object.keys(Be);
var He = function(e4) {
  return Ve.includes(e4);
};
var Je = function(e4) {
  return Te.includes(e4);
};
var Ke = function(e4) {
  return Me.includes(e4);
};
var Le = { rainbow: rainbow_default, sinebow: sinebow_default };
var Ne = qe({}, Ue, $e, Le);
var Qe2 = Object.keys(Ne);
var We = function(e4, r3) {
  if ("function" == typeof e4) return e4;
  if ((0, import_isPlainObject2.default)(e4)) {
    if ((function(e5) {
      return void 0 !== e5.theme;
    })(e4)) {
      if (void 0 === r3) throw new Error("Unable to use color from theme as no theme was provided");
      var n3 = (0, import_get2.default)(r3, e4.theme);
      if (void 0 === n3) throw new Error("Color from theme is undefined at path: '" + e4.theme + "'");
      return function() {
        return n3;
      };
    }
    if ((function(e5) {
      return void 0 !== e5.from;
    })(e4)) {
      var t4 = function(r4) {
        return (0, import_get2.default)(r4, e4.from);
      };
      if (Array.isArray(e4.modifiers)) {
        for (var o3, i3 = [], u3 = function() {
          var e5 = o3.value, r4 = e5[0], n4 = e5[1];
          if ("brighter" === r4) i3.push((function(e6) {
            return e6.brighter(n4);
          }));
          else if ("darker" === r4) i3.push((function(e6) {
            return e6.darker(n4);
          }));
          else {
            if ("opacity" !== r4) throw new Error("Invalid color modifier: '" + r4 + "', must be one of: 'brighter', 'darker', 'opacity'");
            i3.push((function(e6) {
              return e6.opacity = n4, e6;
            }));
          }
        }, a2 = Ge(e4.modifiers); !(o3 = a2()).done; ) u3();
        return 0 === i3.length ? t4 : function(e5) {
          return i3.reduce((function(e6, r4) {
            return r4(e6);
          }), rgb(t4(e5))).toString();
        };
      }
      return t4;
    }
    throw new Error("Invalid color spec, you should either specify 'theme' or 'from' when using a config object");
  }
  return function() {
    return e4;
  };
};
var Xe = function(e4, r3) {
  return (0, import_react17.useMemo)((function() {
    return We(e4, r3);
  }), [e4, r3]);
};
var Ye = import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.func, import_prop_types2.default.shape({ theme: import_prop_types2.default.string.isRequired }), import_prop_types2.default.shape({ from: import_prop_types2.default.string.isRequired, modifiers: import_prop_types2.default.arrayOf(import_prop_types2.default.array) })]);
var Ze2 = { scheme: "turbo" };
var er = function(e4, r3) {
  var n3 = e4.minValue, t4 = e4.maxValue, o3 = void 0 !== n3 ? n3 : r3.min, i3 = void 0 !== t4 ? t4 : r3.max, u3 = sequential().domain([o3, i3]).clamp(true);
  if ("colors" in e4) u3.range(e4.colors);
  else if ("interpolator" in e4) u3.interpolator(e4.interpolator);
  else {
    var a2, l3 = null != (a2 = e4.scheme) ? a2 : Ze2.scheme;
    u3.interpolator(Ne[l3]);
  }
  return u3;
};
var nr = { scheme: "red_yellow_blue", divergeAt: 0.5 };
var tr = function(e4, r3) {
  var n3, t4 = e4.minValue, o3 = e4.maxValue, i3 = void 0 !== t4 ? t4 : r3.min, u3 = void 0 !== o3 ? o3 : r3.max, a2 = [i3, i3 + (u3 - i3) / 2, u3], l3 = 0.5 - (null != (n3 = e4.divergeAt) ? n3 : nr.divergeAt), c9 = diverging().domain(a2).clamp(true), s3 = function(e5) {
    return String(e5);
  };
  if ("colors" in e4) s3 = diverging().domain(a2.map((function(e5) {
    return e5 - l3 * (u3 - i3);
  }))).range(e4.colors).interpolator();
  else if ("interpolator" in e4) s3 = e4.interpolator;
  else {
    var f3, p3 = null != (f3 = e4.scheme) ? f3 : nr.scheme;
    s3 = Ne[p3];
  }
  return c9.interpolator((function(e5) {
    return s3(e5 + l3);
  }));
};
var ir = { scheme: "turbo", steps: 7 };
var ur = function(e4, r3) {
  var n3 = quantize().domain(e4.domain || [r3.min, r3.max]).nice();
  if ("colors" in e4) n3.range(e4.colors);
  else {
    var t4 = e4.scheme || ir.scheme, o3 = void 0 === e4.steps ? ir.steps : e4.steps, i3 = Ne[t4], u3 = Array.from({ length: o3 }).map((function(e5, r4) {
      return i3(r4 * (1 / (o3 - 1)));
    }));
    n3.range(u3);
  }
  return n3;
};
var lr = function(e4, r3) {
  if ((function(e5) {
    return "sequential" === e5.type;
  })(e4)) return er(e4, r3);
  if ((function(e5) {
    return "diverging" === e5.type;
  })(e4)) return tr(e4, r3);
  if ((function(e5) {
    return "quantize" === e5.type;
  })(e4)) return ur(e4, r3);
  throw new Error("Invalid continuous color scale config");
};
var sr = function(e4, r3) {
  void 0 === r3 && (r3 = 16);
  var n3 = e4.domain();
  if ("thresholds" in e4) {
    var t4 = [], o3 = linear().domain(n3).range([0, 1]);
    return e4.range().forEach((function(r4, n4) {
      var i4 = e4.invertExtent(r4), u3 = i4[0], a2 = i4[1];
      t4.push({ key: n4 + ".0", offset: o3(u3), stopColor: r4 }), t4.push({ key: n4 + ".1", offset: o3(a2), stopColor: r4 });
    })), t4;
  }
  var i3 = e4.copy();
  return 2 === n3.length ? i3.domain([0, 1]) : 3 === n3.length && i3.domain([0, 0.5, 1]), i3.ticks(r3).map((function(e5) {
    return { key: "" + e5, offset: e5, stopColor: "" + i3(e5) };
  }));
};
var fr = function(e4, r3) {
  if ("function" == typeof e4) return e4;
  var n3 = "function" == typeof r3 ? r3 : function(e5) {
    return (0, import_get2.default)(e5, r3);
  };
  if (Array.isArray(e4)) {
    var t4 = ordinal(e4), o3 = function(e5) {
      return t4(n3(e5));
    };
    return o3.scale = t4, o3;
  }
  if ((0, import_isPlainObject2.default)(e4)) {
    if ((function(e5) {
      return void 0 !== e5.datum;
    })(e4)) return function(r4) {
      return (0, import_get2.default)(r4, e4.datum);
    };
    if ((function(e5) {
      return void 0 !== e5.scheme;
    })(e4)) {
      if (He(e4.scheme)) {
        var i3 = ordinal(Be[e4.scheme]), u3 = function(e5) {
          return i3(n3(e5));
        };
        return u3.scale = i3, u3;
      }
      if (Je(e4.scheme)) {
        if (void 0 !== e4.size && (e4.size < 3 || e4.size > 11)) throw new Error("Invalid size '" + e4.size + "' for diverging color scheme '" + e4.scheme + "', must be between 3~11");
        var a2 = ordinal(Be[e4.scheme][e4.size || 11]), l3 = function(e5) {
          return a2(n3(e5));
        };
        return l3.scale = a2, l3;
      }
      if (Ke(e4.scheme)) {
        if (void 0 !== e4.size && (e4.size < 3 || e4.size > 9)) throw new Error("Invalid size '" + e4.size + "' for sequential color scheme '" + e4.scheme + "', must be between 3~9");
        var c9 = ordinal(Be[e4.scheme][e4.size || 9]), s3 = function(e5) {
          return c9(n3(e5));
        };
        return s3.scale = c9, s3;
      }
    }
    throw new Error("Invalid colors, when using an object, you should either pass a 'datum' or a 'scheme' property");
  }
  return function() {
    return e4;
  };
};
var pr = function(e4, r3) {
  return (0, import_react17.useMemo)((function() {
    return fr(e4, r3);
  }), [e4, r3]);
};

// node_modules/@nivo/legends/dist/nivo-legends.es.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var c8 = __toESM(require_react());
var import_react18 = __toESM(require_react());
var f2 = function(e4) {
  var i3 = e4.x, n3 = e4.y, o3 = e4.size, r3 = e4.fill, l3 = e4.opacity, a2 = void 0 === l3 ? 1 : l3, c9 = e4.borderWidth, d3 = void 0 === c9 ? 0 : c9, s3 = e4.borderColor;
  return (0, import_jsx_runtime3.jsx)("circle", { r: o3 / 2, cx: i3 + o3 / 2, cy: n3 + o3 / 2, fill: r3, opacity: a2, strokeWidth: d3, stroke: void 0 === s3 ? "transparent" : s3, style: { pointerEvents: "none" } });
};
var m3 = function(e4) {
  var i3 = e4.x, n3 = e4.y, o3 = e4.size, r3 = e4.fill, l3 = e4.opacity, a2 = void 0 === l3 ? 1 : l3, c9 = e4.borderWidth, d3 = void 0 === c9 ? 0 : c9, s3 = e4.borderColor;
  return (0, import_jsx_runtime3.jsx)("g", { transform: "translate(" + i3 + "," + n3 + ")", children: (0, import_jsx_runtime3.jsx)("path", { d: "\n                    M" + o3 / 2 + " 0\n                    L" + 0.8 * o3 + " " + o3 / 2 + "\n                    L" + o3 / 2 + " " + o3 + "\n                    L" + 0.2 * o3 + " " + o3 / 2 + "\n                    L" + o3 / 2 + " 0\n                ", fill: r3, opacity: a2, strokeWidth: d3, stroke: void 0 === s3 ? "transparent" : s3, style: { pointerEvents: "none" } }) });
};
var v3 = function(e4) {
  var i3 = e4.x, n3 = e4.y, o3 = e4.size, r3 = e4.fill, l3 = e4.opacity, a2 = void 0 === l3 ? 1 : l3, c9 = e4.borderWidth, d3 = void 0 === c9 ? 0 : c9, s3 = e4.borderColor;
  return (0, import_jsx_runtime3.jsx)("rect", { x: i3, y: n3, fill: r3, opacity: a2, strokeWidth: d3, stroke: void 0 === s3 ? "transparent" : s3, width: o3, height: o3, style: { pointerEvents: "none" } });
};
var u2 = function(e4) {
  var i3 = e4.x, n3 = e4.y, o3 = e4.size, r3 = e4.fill, l3 = e4.opacity, a2 = void 0 === l3 ? 1 : l3, c9 = e4.borderWidth, d3 = void 0 === c9 ? 0 : c9, s3 = e4.borderColor;
  return (0, import_jsx_runtime3.jsx)("g", { transform: "translate(" + i3 + "," + n3 + ")", children: (0, import_jsx_runtime3.jsx)("path", { d: "\n                M" + o3 / 2 + " 0\n                L" + o3 + " " + o3 + "\n                L0 " + o3 + "\n                L" + o3 / 2 + " 0\n            ", fill: r3, opacity: a2, strokeWidth: d3, stroke: void 0 === s3 ? "transparent" : s3, style: { pointerEvents: "none" } }) });
};
function p2() {
  return p2 = Object.assign ? Object.assign.bind() : function(t4) {
    for (var e4 = 1; e4 < arguments.length; e4++) {
      var i3 = arguments[e4];
      for (var n3 in i3) Object.prototype.hasOwnProperty.call(i3, n3) && (t4[n3] = i3[n3]);
    }
    return t4;
  }, p2.apply(this, arguments);
}
var y3 = { length: 200, thickness: 16, direction: "row", tickPosition: "after", tickSize: 4, tickSpacing: 3, tickOverlap: false, tickFormat: function(t4) {
  return "" + t4;
}, titleAlign: "start", titleOffset: 4 };
var k2 = { top: 0, right: 0, bottom: 0, left: 0 };
var x2 = function(t4) {
  var e4, i3 = t4.direction, n3 = t4.itemsSpacing, o3 = t4.padding, r3 = t4.itemCount, l3 = t4.itemWidth, a2 = t4.itemHeight;
  if ("number" != typeof o3 && ("object" != typeof (e4 = o3) || Array.isArray(e4) || null === e4)) throw new Error("Invalid property padding, must be one of: number, object");
  var c9 = "number" == typeof o3 ? { top: o3, right: o3, bottom: o3, left: o3 } : p2({}, k2, o3), d3 = c9.left + c9.right, s3 = c9.top + c9.bottom, h2 = l3 + d3, g3 = a2 + s3, f3 = (r3 - 1) * n3;
  return "row" === i3 ? h2 = l3 * r3 + f3 + d3 : "column" === i3 && (g3 = a2 * r3 + f3 + s3), { width: h2, height: g3, padding: c9 };
};
var b2 = function(t4) {
  var e4 = t4.anchor, i3 = t4.translateX, n3 = t4.translateY, o3 = t4.containerWidth, r3 = t4.containerHeight, l3 = t4.width, a2 = t4.height, c9 = i3, d3 = n3;
  switch (e4) {
    case "top":
      c9 += (o3 - l3) / 2;
      break;
    case "top-right":
      c9 += o3 - l3;
      break;
    case "right":
      c9 += o3 - l3, d3 += (r3 - a2) / 2;
      break;
    case "bottom-right":
      c9 += o3 - l3, d3 += r3 - a2;
      break;
    case "bottom":
      c9 += (o3 - l3) / 2, d3 += r3 - a2;
      break;
    case "bottom-left":
      d3 += r3 - a2;
      break;
    case "left":
      d3 += (r3 - a2) / 2;
      break;
    case "center":
      c9 += (o3 - l3) / 2, d3 += (r3 - a2) / 2;
  }
  return { x: c9, y: d3 };
};
var S = function(t4) {
  var e4, i3, n3, o3, r3, l3, a2 = t4.direction, c9 = t4.justify, d3 = t4.symbolSize, s3 = t4.symbolSpacing, h2 = t4.width, g3 = t4.height;
  switch (a2) {
    case "left-to-right":
      e4 = 0, i3 = (g3 - d3) / 2, o3 = g3 / 2, l3 = "central", c9 ? (n3 = h2, r3 = "end") : (n3 = d3 + s3, r3 = "start");
      break;
    case "right-to-left":
      e4 = h2 - d3, i3 = (g3 - d3) / 2, o3 = g3 / 2, l3 = "central", c9 ? (n3 = 0, r3 = "start") : (n3 = h2 - d3 - s3, r3 = "end");
      break;
    case "top-to-bottom":
      e4 = (h2 - d3) / 2, i3 = 0, n3 = h2 / 2, r3 = "middle", c9 ? (o3 = g3, l3 = "alphabetic") : (o3 = d3 + s3, l3 = "text-before-edge");
      break;
    case "bottom-to-top":
      e4 = (h2 - d3) / 2, i3 = g3 - d3, n3 = h2 / 2, r3 = "middle", c9 ? (o3 = 0, l3 = "text-before-edge") : (o3 = g3 - d3 - s3, l3 = "alphabetic");
  }
  return { symbolX: e4, symbolY: i3, labelX: n3, labelY: o3, labelAnchor: r3, labelAlignment: l3 };
};
var A2 = function(t4) {
  var e4, o3 = t4.scale, r3 = t4.ticks, l3 = t4.length, c9 = void 0 === l3 ? y3.length : l3, d3 = t4.thickness, s3 = void 0 === d3 ? y3.thickness : d3, h2 = t4.direction, g3 = void 0 === h2 ? y3.direction : h2, f3 = t4.tickPosition, m4 = void 0 === f3 ? y3.tickPosition : f3, v4 = t4.tickSize, u3 = void 0 === v4 ? y3.tickSize : v4, p3 = t4.tickSpacing, k3 = void 0 === p3 ? y3.tickSpacing : p3, x3 = t4.tickOverlap, b3 = void 0 === x3 ? y3.tickOverlap : x3, S2 = t4.tickFormat, A3 = void 0 === S2 ? y3.tickFormat : S2, W3 = t4.title, z4 = t4.titleAlign, C4 = void 0 === z4 ? y3.titleAlign : z4, w3 = t4.titleOffset, X2 = void 0 === w3 ? y3.titleOffset : w3, Y2 = "column" === g3 ? [].concat(o3.domain()).reverse() : o3.domain(), O4 = linear().domain(Y2);
  2 === Y2.length ? O4.range([0, c9]) : 3 === Y2.length && O4.range([0, c9 / 2, c9]), e4 = "thresholds" in o3 ? [Y2[0]].concat(o3.thresholds(), [Y2[1]]) : Array.isArray(r3) ? r3 : o3.ticks(r3);
  var B, H, E3, j2, L, M2, F2 = sr(o3, 32), T2 = xt(A3), P2 = [], V2 = 0, R = 0;
  if ("row" === g3) {
    var D, q2, G;
    B = c9, H = s3, R = 1;
    var I;
    L = 0, E3 = "start" === C4 ? 0 : "middle" === C4 ? c9 / 2 : c9, "before" === m4 ? (D = -u3, q2 = b3 ? s3 : 0, G = -u3 - k3, I = "alphabetic", j2 = s3 + X2, M2 = "hanging") : (D = b3 ? 0 : s3, G = (q2 = s3 + u3) + k3, I = "hanging", j2 = -X2, M2 = "alphabetic"), e4.forEach((function(t5) {
      var e5 = O4(t5);
      P2.push({ x1: e5, y1: D, x2: e5, y2: q2, text: T2(t5), textX: e5, textY: G, textHorizontalAlign: "middle", textVerticalAlign: I });
    }));
  } else {
    var N2, _, J, K;
    B = s3, H = c9, V2 = 1;
    L = -90, j2 = "start" === C4 ? c9 : "middle" === C4 ? c9 / 2 : 0, "before" === m4 ? (_ = b3 ? s3 : 0, J = (N2 = -u3) - k3, K = "end", E3 = s3 + X2, M2 = "hanging") : (N2 = b3 ? 0 : s3, J = (_ = s3 + u3) + k3, K = "start", E3 = -X2, M2 = "alphabetic"), e4.forEach((function(t5) {
      var e5 = O4(t5);
      P2.push({ x1: N2, y1: e5, x2: _, y2: e5, text: T2(t5), textX: J, textY: e5, textHorizontalAlign: K, textVerticalAlign: "central" });
    }));
  }
  return { width: B, height: H, gradientX1: 0, gradientY1: V2, gradientX2: R, gradientY2: 0, colorStops: F2, ticks: P2, titleText: W3, titleX: E3, titleY: j2, titleRotation: L, titleHorizontalAlign: C4, titleVerticalAlign: M2 };
};
var W2 = function(i3) {
  var n3 = i3.scale, r3 = i3.ticks, l3 = i3.length, a2 = void 0 === l3 ? y3.length : l3, c9 = i3.thickness, s3 = void 0 === c9 ? y3.thickness : c9, h2 = i3.direction, g3 = void 0 === h2 ? y3.direction : h2, f3 = i3.tickPosition, m4 = void 0 === f3 ? y3.tickPosition : f3, v4 = i3.tickSize, u3 = void 0 === v4 ? y3.tickSize : v4, k3 = i3.tickSpacing, x3 = void 0 === k3 ? y3.tickSpacing : k3, b3 = i3.tickOverlap, S2 = void 0 === b3 ? y3.tickOverlap : b3, W3 = i3.tickFormat, z4 = void 0 === W3 ? y3.tickFormat : W3, C4 = i3.title, w3 = i3.titleAlign, X2 = void 0 === w3 ? y3.titleAlign : w3, Y2 = i3.titleOffset, O4 = A2({ scale: n3, ticks: r3, length: a2, thickness: s3, direction: g3, tickPosition: m4, tickSize: u3, tickSpacing: x3, tickOverlap: S2, tickFormat: z4, title: C4, titleAlign: X2, titleOffset: void 0 === Y2 ? y3.titleOffset : Y2 }), B = O4.width, H = O4.height, E3 = O4.gradientX1, j2 = O4.gradientY1, L = O4.gradientX2, M2 = O4.gradientY2, F2 = O4.ticks, T2 = O4.colorStops, P2 = O4.titleText, V2 = O4.titleX, R = O4.titleY, D = O4.titleRotation, q2 = O4.titleVerticalAlign, G = O4.titleHorizontalAlign, I = zt(), N2 = "ContinuousColorsLegendSvgGradient." + g3 + "." + T2.map((function(t4) {
    return t4.offset;
  })).join("_");
  return (0, import_jsx_runtime3.jsxs)("g", { children: [(0, import_jsx_runtime3.jsx)("defs", { children: (0, import_jsx_runtime3.jsx)("linearGradient", { id: N2, x1: E3, y1: j2, x2: L, y2: M2, children: T2.map((function(e4) {
    return (0, import_jsx_runtime3.jsx)("stop", p2({}, e4));
  })) }) }), P2 && (0, import_jsx_runtime3.jsx)("text", { transform: "translate(" + V2 + ", " + R + ") rotate(" + D + ")", textAnchor: G, dominantBaseline: q2, style: I.legends.title.text, children: P2 }), (0, import_jsx_runtime3.jsx)("rect", { width: B, height: H, fill: "url(#" + N2 }), F2.map((function(i4, n4) {
    return (0, import_jsx_runtime3.jsxs)(import_react18.Fragment, { children: [(0, import_jsx_runtime3.jsx)("line", { x1: i4.x1, y1: i4.y1, x2: i4.x2, y2: i4.y2, style: I.legends.ticks.line }), (0, import_jsx_runtime3.jsx)("text", { x: i4.textX, y: i4.textY, textAnchor: i4.textHorizontalAlign, dominantBaseline: i4.textVerticalAlign, style: I.legends.ticks.text, children: i4.text })] }, n4);
  }))] });
};
var z3 = ["containerWidth", "containerHeight", "anchor", "translateX", "translateY", "length", "thickness", "direction"];
var C3 = function(e4) {
  var i3, n3, o3 = e4.containerWidth, r3 = e4.containerHeight, l3 = e4.anchor, a2 = e4.translateX, c9 = void 0 === a2 ? 0 : a2, d3 = e4.translateY, s3 = void 0 === d3 ? 0 : d3, h2 = e4.length, g3 = void 0 === h2 ? y3.length : h2, f3 = e4.thickness, m4 = void 0 === f3 ? y3.thickness : f3, v4 = e4.direction, u3 = void 0 === v4 ? y3.direction : v4, k3 = (function(t4, e5) {
    if (null == t4) return {};
    var i4, n4, o4 = {}, r4 = Object.keys(t4);
    for (n4 = 0; n4 < r4.length; n4++) i4 = r4[n4], e5.indexOf(i4) >= 0 || (o4[i4] = t4[i4]);
    return o4;
  })(e4, z3);
  "row" === u3 ? (i3 = g3, n3 = m4) : (i3 = m4, n3 = g3);
  var x3 = b2({ anchor: l3, translateX: c9, translateY: s3, containerWidth: o3, containerHeight: r3, width: i3, height: n3 }), S2 = x3.x, A3 = x3.y;
  return (0, import_jsx_runtime3.jsx)("g", { transform: "translate(" + S2 + ", " + A3 + ")", children: (0, import_jsx_runtime3.jsx)(W2, p2({ length: g3, thickness: m4, direction: u3 }, k3)) });
};
var w2 = { circle: f2, diamond: m3, square: v3, triangle: u2 };
var X = function(i3) {
  var n3, l3, a2, d3, g3, f3, m4, v4, u3, y4, k3, x3 = i3.x, b3 = i3.y, A3 = i3.width, W3 = i3.height, z4 = i3.data, C4 = i3.direction, X2 = void 0 === C4 ? "left-to-right" : C4, Y2 = i3.justify, O4 = void 0 !== Y2 && Y2, B = i3.textColor, H = i3.background, E3 = void 0 === H ? "transparent" : H, j2 = i3.opacity, L = void 0 === j2 ? 1 : j2, M2 = i3.symbolShape, F2 = void 0 === M2 ? "square" : M2, T2 = i3.symbolSize, P2 = void 0 === T2 ? 16 : T2, V2 = i3.symbolSpacing, R = void 0 === V2 ? 8 : V2, D = i3.symbolBorderWidth, q2 = void 0 === D ? 0 : D, G = i3.symbolBorderColor, I = void 0 === G ? "transparent" : G, N2 = i3.onClick, _ = i3.onMouseEnter, J = i3.onMouseLeave, K = i3.toggleSerie, Q = i3.effects, U = (0, import_react18.useState)({}), Z = U[0], $ = U[1], tt2 = zt(), et2 = (0, import_react18.useCallback)((function(t4) {
    if (Q) {
      var e4 = Q.filter((function(t5) {
        return "hover" === t5.on;
      })).reduce((function(t5, e5) {
        return p2({}, t5, e5.style);
      }), {});
      $(e4);
    }
    null == _ || _(z4, t4);
  }), [_, z4, Q]), it2 = (0, import_react18.useCallback)((function(t4) {
    if (Q) {
      var e4 = Q.filter((function(t5) {
        return "hover" !== t5.on;
      })).reduce((function(t5, e5) {
        return p2({}, t5, e5.style);
      }), {});
      $(e4);
    }
    null == J || J(z4, t4);
  }), [J, z4, Q]), nt2 = S({ direction: X2, justify: O4, symbolSize: null != (n3 = Z.symbolSize) ? n3 : P2, symbolSpacing: R, width: A3, height: W3 }), ot2 = nt2.symbolX, rt2 = nt2.symbolY, lt2 = nt2.labelX, at2 = nt2.labelY, ct2 = nt2.labelAnchor, dt2 = nt2.labelAlignment, st = [N2, _, J, K].some((function(t4) {
    return void 0 !== t4;
  })), ht2 = "function" == typeof F2 ? F2 : w2[F2];
  return (0, import_jsx_runtime3.jsxs)("g", { transform: "translate(" + x3 + "," + b3 + ")", style: { opacity: null != (l3 = Z.itemOpacity) ? l3 : L }, children: [(0, import_jsx_runtime3.jsx)("rect", { width: A3, height: W3, fill: null != (a2 = Z.itemBackground) ? a2 : E3, style: { cursor: st ? "pointer" : "auto" }, onClick: function(t4) {
    null == N2 || N2(z4, t4), null == K || K(z4.id);
  }, onMouseEnter: et2, onMouseLeave: it2 }), c8.createElement(ht2, p2({ id: z4.id, x: ot2, y: rt2, size: null != (d3 = Z.symbolSize) ? d3 : P2, fill: null != (g3 = null != (f3 = z4.fill) ? f3 : z4.color) ? g3 : "black", borderWidth: null != (m4 = Z.symbolBorderWidth) ? m4 : q2, borderColor: null != (v4 = Z.symbolBorderColor) ? v4 : I }, z4.hidden ? tt2.legends.hidden.symbol : void 0)), (0, import_jsx_runtime3.jsx)("text", { textAnchor: ct2, style: p2({}, Mt(tt2.legends.text), { fill: null != (u3 = null != (y4 = null != (k3 = Z.itemTextColor) ? k3 : B) ? y4 : tt2.legends.text.fill) ? u3 : "black", dominantBaseline: dt2, pointerEvents: "none", userSelect: "none" }, z4.hidden ? tt2.legends.hidden.text : void 0), x: lt2, y: at2, children: z4.label })] });
};
var Y = function(e4) {
  var i3 = e4.data, n3 = e4.x, o3 = e4.y, r3 = e4.direction, l3 = e4.padding, a2 = void 0 === l3 ? 0 : l3, c9 = e4.justify, d3 = e4.effects, s3 = e4.itemWidth, h2 = e4.itemHeight, g3 = e4.itemDirection, f3 = void 0 === g3 ? "left-to-right" : g3, m4 = e4.itemsSpacing, v4 = void 0 === m4 ? 0 : m4, u3 = e4.itemTextColor, p3 = e4.itemBackground, y4 = void 0 === p3 ? "transparent" : p3, k3 = e4.itemOpacity, b3 = void 0 === k3 ? 1 : k3, S2 = e4.symbolShape, A3 = e4.symbolSize, W3 = e4.symbolSpacing, z4 = e4.symbolBorderWidth, C4 = e4.symbolBorderColor, w3 = e4.onClick, Y2 = e4.onMouseEnter, O4 = e4.onMouseLeave, B = e4.toggleSerie, H = x2({ itemCount: i3.length, itemWidth: s3, itemHeight: h2, itemsSpacing: v4, direction: r3, padding: a2 }).padding, E3 = "row" === r3 ? s3 + v4 : 0, j2 = "column" === r3 ? h2 + v4 : 0;
  return (0, import_jsx_runtime3.jsx)("g", { transform: "translate(" + n3 + "," + o3 + ")", children: i3.map((function(e5, i4) {
    return (0, import_jsx_runtime3.jsx)(X, { data: e5, x: i4 * E3 + H.left, y: i4 * j2 + H.top, width: s3, height: h2, direction: f3, justify: c9, effects: d3, textColor: u3, background: y4, opacity: b3, symbolShape: S2, symbolSize: A3, symbolSpacing: W3, symbolBorderWidth: z4, symbolBorderColor: C4, onClick: w3, onMouseEnter: Y2, onMouseLeave: O4, toggleSerie: B }, i4);
  })) });
};
var O3 = function(e4) {
  var i3 = e4.data, n3 = e4.containerWidth, o3 = e4.containerHeight, r3 = e4.translateX, l3 = void 0 === r3 ? 0 : r3, a2 = e4.translateY, c9 = void 0 === a2 ? 0 : a2, d3 = e4.anchor, s3 = e4.direction, h2 = e4.padding, g3 = void 0 === h2 ? 0 : h2, f3 = e4.justify, m4 = e4.itemsSpacing, v4 = void 0 === m4 ? 0 : m4, u3 = e4.itemWidth, p3 = e4.itemHeight, y4 = e4.itemDirection, k3 = e4.itemTextColor, S2 = e4.itemBackground, A3 = e4.itemOpacity, W3 = e4.symbolShape, z4 = e4.symbolSize, C4 = e4.symbolSpacing, w3 = e4.symbolBorderWidth, X2 = e4.symbolBorderColor, O4 = e4.onClick, B = e4.onMouseEnter, H = e4.onMouseLeave, E3 = e4.toggleSerie, j2 = e4.effects, L = x2({ itemCount: i3.length, itemsSpacing: v4, itemWidth: u3, itemHeight: p3, direction: s3, padding: g3 }), M2 = L.width, F2 = L.height, T2 = b2({ anchor: d3, translateX: l3, translateY: c9, containerWidth: n3, containerHeight: o3, width: M2, height: F2 }), P2 = T2.x, V2 = T2.y;
  return (0, import_jsx_runtime3.jsx)(Y, { data: i3, x: P2, y: V2, direction: s3, padding: g3, justify: f3, effects: j2, itemsSpacing: v4, itemWidth: u3, itemHeight: p3, itemDirection: y4, itemTextColor: k3, itemBackground: S2, itemOpacity: A3, symbolShape: W3, symbolSize: z4, symbolSpacing: C4, symbolBorderWidth: w3, symbolBorderColor: X2, onClick: O4, onMouseEnter: B, onMouseLeave: H, toggleSerie: "boolean" == typeof E3 ? void 0 : E3 });
};
var E2 = function(t4, e4) {
  var i3 = e4.containerWidth, n3 = e4.containerHeight, o3 = e4.anchor, r3 = e4.translateX, a2 = void 0 === r3 ? 0 : r3, c9 = e4.translateY, d3 = void 0 === c9 ? 0 : c9, s3 = e4.scale, h2 = e4.length, g3 = void 0 === h2 ? y3.length : h2, f3 = e4.thickness, m4 = void 0 === f3 ? y3.thickness : f3, v4 = e4.direction, u3 = void 0 === v4 ? y3.direction : v4, p3 = e4.ticks, k3 = e4.tickPosition, x3 = void 0 === k3 ? y3.tickPosition : k3, S2 = e4.tickSize, W3 = void 0 === S2 ? y3.tickSize : S2, z4 = e4.tickSpacing, C4 = void 0 === z4 ? y3.tickSpacing : z4, w3 = e4.tickOverlap, X2 = void 0 === w3 ? y3.tickOverlap : w3, Y2 = e4.tickFormat, O4 = void 0 === Y2 ? y3.tickFormat : Y2, B = e4.title, H = e4.titleAlign, E3 = void 0 === H ? y3.titleAlign : H, j2 = e4.titleOffset, L = void 0 === j2 ? y3.titleOffset : j2, M2 = e4.theme, F2 = A2({ scale: s3, ticks: p3, length: g3, thickness: m4, direction: u3, tickPosition: x3, tickSize: W3, tickSpacing: C4, tickOverlap: X2, tickFormat: O4, title: B, titleAlign: E3, titleOffset: L }), T2 = F2.width, P2 = F2.height, V2 = F2.gradientX1, R = F2.gradientY1, D = F2.gradientX2, q2 = F2.gradientY2, G = F2.colorStops, I = F2.ticks, N2 = F2.titleText, _ = F2.titleX, J = F2.titleY, K = F2.titleRotation, Q = F2.titleVerticalAlign, U = F2.titleHorizontalAlign, Z = b2({ anchor: o3, translateX: a2, translateY: d3, containerWidth: i3, containerHeight: n3, width: T2, height: P2 }), $ = Z.x, tt2 = Z.y, et2 = { font: t4.font, textAlign: t4.textAlign, textBaseline: t4.textBaseline };
  t4.save(), t4.translate($, tt2);
  var it2 = t4.createLinearGradient(V2 * T2, R * P2, D * T2, q2 * P2);
  G.forEach((function(t5) {
    it2.addColorStop(t5.offset, t5.stopColor);
  })), t4.fillStyle = it2, t4.fillRect(0, 0, T2, P2), t4.font = (M2.legends.ticks.text.fontWeight ? M2.legends.ticks.text.fontWeight + " " : "") + M2.legends.ticks.text.fontSize + "px " + M2.legends.ticks.text.fontFamily, I.forEach((function(e5) {
    var i4;
    (null != (i4 = M2.legends.ticks.line.strokeWidth) ? i4 : 0) > 0 && (t4.lineWidth = Number(M2.axis.ticks.line.strokeWidth), M2.axis.ticks.line.stroke && (t4.strokeStyle = M2.axis.ticks.line.stroke), t4.lineCap = "square", t4.beginPath(), t4.moveTo(e5.x1, e5.y1), t4.lineTo(e5.x2, e5.y2), t4.stroke()), M2.legends.ticks.text.fill && (t4.fillStyle = M2.legends.ticks.text.fill), t4.textAlign = "middle" === e5.textHorizontalAlign ? "center" : e5.textHorizontalAlign, t4.textBaseline = "central" === e5.textVerticalAlign ? "middle" : e5.textVerticalAlign, t4.fillText(e5.text, e5.textX, e5.textY);
  })), N2 && (t4.save(), t4.translate(_, J), t4.rotate(Kt(K)), t4.font = (M2.legends.title.text.fontWeight ? M2.legends.title.text.fontWeight + " " : "") + M2.legends.title.text.fontSize + "px " + M2.legends.title.text.fontFamily, M2.legends.title.text.fill && (t4.fillStyle = M2.legends.title.text.fill), t4.textAlign = "middle" === U ? "center" : U, t4.textBaseline = Q, t4.fillText(N2, 0, 0), t4.restore()), t4.restore(), t4.font = et2.font, t4.textAlign = et2.textAlign, t4.textBaseline = et2.textBaseline;
};

export {
  useSprings,
  useSpring,
  useTransition,
  to2 as to,
  animated,
  g,
  w,
  C2 as C,
  k,
  Ur,
  Fr,
  bt,
  wt,
  Ot,
  zt,
  Mt,
  St,
  It,
  Kt,
  Nt,
  Jt,
  Qt,
  rn,
  gn,
  vn,
  Wn,
  jn,
  Sn,
  In,
  We,
  Xe,
  lr,
  pr,
  C3 as C2,
  O3 as O,
  E2 as E
};
//# sourceMappingURL=chunk-3YO72H2Y.js.map
